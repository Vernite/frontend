var _a,_b;import{compare,compareIgnoreCase,compareSubstring,compareSubstringIgnoreCase}from"./strings.js";export class StringIterator{constructor(){this._value="",this._pos=0}reset(key){return this._value=key,this._pos=0,this}next(){return this._pos+=1,this}hasNext(){return this._pos<this._value.length-1}cmp(a){return a.charCodeAt(0)-this._value.charCodeAt(this._pos)}value(){return this._value[this._pos]}}export class ConfigKeysIterator{constructor(_caseSensitive=!0){this._caseSensitive=_caseSensitive}reset(key){return this._value=key,this._from=0,this._to=0,this.next()}hasNext(){return this._to<this._value.length}next(){this._from=this._to;let justSeps=!0;for(;this._to<this._value.length;this._to++){if(46===this._value.charCodeAt(this._to)){if(!justSeps)break;this._from++}else justSeps=!1}return this}cmp(a){return this._caseSensitive?compareSubstring(a,this._value,0,a.length,this._from,this._to):compareSubstringIgnoreCase(a,this._value,0,a.length,this._from,this._to)}value(){return this._value.substring(this._from,this._to)}}export class PathIterator{constructor(_splitOnBackslash=!0,_caseSensitive=!0){this._splitOnBackslash=_splitOnBackslash,this._caseSensitive=_caseSensitive}reset(key){this._from=0,this._to=0,this._value=key,this._valueLen=key.length;for(let pos=key.length-1;pos>=0;pos--,this._valueLen--){const ch=this._value.charCodeAt(pos);if(!(47===ch||this._splitOnBackslash&&92===ch))break}return this.next()}hasNext(){return this._to<this._valueLen}next(){this._from=this._to;let justSeps=!0;for(;this._to<this._valueLen;this._to++){const ch=this._value.charCodeAt(this._to);if(47===ch||this._splitOnBackslash&&92===ch){if(!justSeps)break;this._from++}else justSeps=!1}return this}cmp(a){return this._caseSensitive?compareSubstring(a,this._value,0,a.length,this._from,this._to):compareSubstringIgnoreCase(a,this._value,0,a.length,this._from,this._to)}value(){return this._value.substring(this._from,this._to)}}export class UriIterator{constructor(_ignorePathCasing,_ignoreQueryAndFragment){this._ignorePathCasing=_ignorePathCasing,this._ignoreQueryAndFragment=_ignoreQueryAndFragment,this._states=[],this._stateIdx=0}reset(key){return this._value=key,this._states=[],this._value.scheme&&this._states.push(1),this._value.authority&&this._states.push(2),this._value.path&&(this._pathIterator=new PathIterator(!1,!this._ignorePathCasing(key)),this._pathIterator.reset(key.path),this._pathIterator.value()&&this._states.push(3)),this._ignoreQueryAndFragment(key)||(this._value.query&&this._states.push(4),this._value.fragment&&this._states.push(5)),this._stateIdx=0,this}next(){return 3===this._states[this._stateIdx]&&this._pathIterator.hasNext()?this._pathIterator.next():this._stateIdx+=1,this}hasNext(){return 3===this._states[this._stateIdx]&&this._pathIterator.hasNext()||this._stateIdx<this._states.length-1}cmp(a){if(1===this._states[this._stateIdx])return compareIgnoreCase(a,this._value.scheme);if(2===this._states[this._stateIdx])return compareIgnoreCase(a,this._value.authority);if(3===this._states[this._stateIdx])return this._pathIterator.cmp(a);if(4===this._states[this._stateIdx])return compare(a,this._value.query);if(5===this._states[this._stateIdx])return compare(a,this._value.fragment);throw new Error}value(){if(1===this._states[this._stateIdx])return this._value.scheme;if(2===this._states[this._stateIdx])return this._value.authority;if(3===this._states[this._stateIdx])return this._pathIterator.value();if(4===this._states[this._stateIdx])return this._value.query;if(5===this._states[this._stateIdx])return this._value.fragment;throw new Error}}class TernarySearchTreeNode{constructor(){this.height=1}rotateLeft(){const tmp=this.right;return this.right=tmp.left,tmp.left=this,this.updateHeight(),tmp.updateHeight(),tmp}rotateRight(){const tmp=this.left;return this.left=tmp.right,tmp.right=this,this.updateHeight(),tmp.updateHeight(),tmp}updateHeight(){this.height=1+Math.max(this.heightLeft,this.heightRight)}balanceFactor(){return this.heightRight-this.heightLeft}get heightLeft(){var _c,_d;return null!==(_d=null===(_c=this.left)||void 0===_c?void 0:_c.height)&&void 0!==_d?_d:0}get heightRight(){var _c,_d;return null!==(_d=null===(_c=this.right)||void 0===_c?void 0:_c.height)&&void 0!==_d?_d:0}}export class TernarySearchTree{constructor(segments){this._iter=segments}static forUris(ignorePathCasing=(()=>!1),ignoreQueryAndFragment=(()=>!1)){return new TernarySearchTree(new UriIterator(ignorePathCasing,ignoreQueryAndFragment))}static forStrings(){return new TernarySearchTree(new StringIterator)}static forConfigKeys(){return new TernarySearchTree(new ConfigKeysIterator)}clear(){this._root=void 0}set(key,element){const iter=this._iter.reset(key);let node;this._root||(this._root=new TernarySearchTreeNode,this._root.segment=iter.value());const stack=[];for(node=this._root;;){const val=iter.cmp(node.segment);if(val>0)node.left||(node.left=new TernarySearchTreeNode,node.left.segment=iter.value()),stack.push([-1,node]),node=node.left;else if(val<0)node.right||(node.right=new TernarySearchTreeNode,node.right.segment=iter.value()),stack.push([1,node]),node=node.right;else{if(!iter.hasNext())break;iter.next(),node.mid||(node.mid=new TernarySearchTreeNode,node.mid.segment=iter.value()),stack.push([0,node]),node=node.mid}}const oldElement=node.value;node.value=element,node.key=key;for(let i=stack.length-1;i>=0;i--){const node=stack[i][1];node.updateHeight();const bf=node.balanceFactor();if(bf<-1||bf>1){const d1=stack[i][0],d2=stack[i+1][0];if(1===d1&&1===d2)stack[i][1]=node.rotateLeft();else if(-1===d1&&-1===d2)stack[i][1]=node.rotateRight();else if(1===d1&&-1===d2)node.right=stack[i+1][1]=stack[i+1][1].rotateRight(),stack[i][1]=node.rotateLeft();else{if(-1!==d1||1!==d2)throw new Error;node.left=stack[i+1][1]=stack[i+1][1].rotateLeft(),stack[i][1]=node.rotateRight()}if(i>0)switch(stack[i-1][0]){case-1:stack[i-1][1].left=stack[i][1];break;case 1:stack[i-1][1].right=stack[i][1];break;case 0:stack[i-1][1].mid=stack[i][1]}else this._root=stack[0][1]}}return oldElement}get(key){var _c;return null===(_c=this._getNode(key))||void 0===_c?void 0:_c.value}_getNode(key){const iter=this._iter.reset(key);let node=this._root;for(;node;){const val=iter.cmp(node.segment);if(val>0)node=node.left;else if(val<0)node=node.right;else{if(!iter.hasNext())break;iter.next(),node=node.mid}}return node}has(key){const node=this._getNode(key);return!(void 0===(null==node?void 0:node.value)&&void 0===(null==node?void 0:node.mid))}delete(key){return this._delete(key,!1)}deleteSuperstr(key){return this._delete(key,!0)}_delete(key,superStr){var _c;const iter=this._iter.reset(key),stack=[];let node=this._root;for(;node;){const val=iter.cmp(node.segment);if(val>0)stack.push([-1,node]),node=node.left;else if(val<0)stack.push([1,node]),node=node.right;else{if(!iter.hasNext())break;iter.next(),stack.push([0,node]),node=node.mid}}if(node){if(superStr?(node.left=void 0,node.mid=void 0,node.right=void 0,node.height=1):(node.key=void 0,node.value=void 0),!node.mid&&!node.value)if(node.left&&node.right){const min=this._min(node.right),{key,value,segment}=min;this._delete(min.key,!1),node.key=key,node.value=value,node.segment=segment}else{const newChild=null!==(_c=node.left)&&void 0!==_c?_c:node.right;if(stack.length>0){const[dir,parent]=stack[stack.length-1];switch(dir){case-1:parent.left=newChild;break;case 0:parent.mid=newChild;break;case 1:parent.right=newChild}}else this._root=newChild}for(let i=stack.length-1;i>=0;i--){const node=stack[i][1];node.updateHeight();const bf=node.balanceFactor();if(bf>1?(node.right.balanceFactor()>=0||(node.right=node.right.rotateRight()),stack[i][1]=node.rotateLeft()):bf<-1&&(node.left.balanceFactor()<=0||(node.left=node.left.rotateLeft()),stack[i][1]=node.rotateRight()),i>0)switch(stack[i-1][0]){case-1:stack[i-1][1].left=stack[i][1];break;case 1:stack[i-1][1].right=stack[i][1];break;case 0:stack[i-1][1].mid=stack[i][1]}else this._root=stack[0][1]}}}_min(node){for(;node.left;)node=node.left;return node}findSubstr(key){const iter=this._iter.reset(key);let candidate,node=this._root;for(;node;){const val=iter.cmp(node.segment);if(val>0)node=node.left;else if(val<0)node=node.right;else{if(!iter.hasNext())break;iter.next(),candidate=node.value||candidate,node=node.mid}}return node&&node.value||candidate}findSuperstr(key){const iter=this._iter.reset(key);let node=this._root;for(;node;){const val=iter.cmp(node.segment);if(val>0)node=node.left;else if(val<0)node=node.right;else{if(!iter.hasNext())return node.mid?this._entries(node.mid):void 0;iter.next(),node=node.mid}}}forEach(callback){for(const[key,value]of this)callback(value,key)}*[Symbol.iterator](){yield*this._entries(this._root)}_entries(node){const result=[];return this._dfsEntries(node,result),result[Symbol.iterator]()}_dfsEntries(node,bucket){node&&(node.left&&this._dfsEntries(node.left,bucket),node.value&&bucket.push([node.key,node.value]),node.mid&&this._dfsEntries(node.mid,bucket),node.right&&this._dfsEntries(node.right,bucket))}}class ResourceMapEntry{constructor(uri,value){this.uri=uri,this.value=value}}export class ResourceMap{constructor(mapOrKeyFn,toKey){this[_a]="ResourceMap",mapOrKeyFn instanceof ResourceMap?(this.map=new Map(mapOrKeyFn.map),this.toKey=null!=toKey?toKey:ResourceMap.defaultToKey):(this.map=new Map,this.toKey=null!=mapOrKeyFn?mapOrKeyFn:ResourceMap.defaultToKey)}set(resource,value){return this.map.set(this.toKey(resource),new ResourceMapEntry(resource,value)),this}get(resource){var _c;return null===(_c=this.map.get(this.toKey(resource)))||void 0===_c?void 0:_c.value}has(resource){return this.map.has(this.toKey(resource))}get size(){return this.map.size}clear(){this.map.clear()}delete(resource){return this.map.delete(this.toKey(resource))}forEach(clb,thisArg){void 0!==thisArg&&(clb=clb.bind(thisArg));for(const[_,entry]of this.map)clb(entry.value,entry.uri,this)}*values(){for(const entry of this.map.values())yield entry.value}*keys(){for(const entry of this.map.values())yield entry.uri}*entries(){for(const entry of this.map.values())yield[entry.uri,entry.value]}*[(_a=Symbol.toStringTag,Symbol.iterator)](){for(const[,entry]of this.map)yield[entry.uri,entry.value]}}ResourceMap.defaultToKey=resource=>resource.toString();export class LinkedMap{constructor(){this[_b]="LinkedMap",this._map=new Map,this._head=void 0,this._tail=void 0,this._size=0,this._state=0}clear(){this._map.clear(),this._head=void 0,this._tail=void 0,this._size=0,this._state++}isEmpty(){return!this._head&&!this._tail}get size(){return this._size}get first(){var _c;return null===(_c=this._head)||void 0===_c?void 0:_c.value}get last(){var _c;return null===(_c=this._tail)||void 0===_c?void 0:_c.value}has(key){return this._map.has(key)}get(key,touch=0){const item=this._map.get(key);if(item)return 0!==touch&&this.touch(item,touch),item.value}set(key,value,touch=0){let item=this._map.get(key);if(item)item.value=value,0!==touch&&this.touch(item,touch);else{switch(item={key,value,next:void 0,previous:void 0},touch){case 0:case 2:default:this.addItemLast(item);break;case 1:this.addItemFirst(item)}this._map.set(key,item),this._size++}return this}delete(key){return!!this.remove(key)}remove(key){const item=this._map.get(key);if(item)return this._map.delete(key),this.removeItem(item),this._size--,item.value}shift(){if(!this._head&&!this._tail)return;if(!this._head||!this._tail)throw new Error("Invalid list");const item=this._head;return this._map.delete(item.key),this.removeItem(item),this._size--,item.value}forEach(callbackfn,thisArg){const state=this._state;let current=this._head;for(;current;){if(thisArg?callbackfn.bind(thisArg)(current.value,current.key,this):callbackfn(current.value,current.key,this),this._state!==state)throw new Error("LinkedMap got modified during iteration.");current=current.next}}keys(){const map=this,state=this._state;let current=this._head;const iterator={[Symbol.iterator]:()=>iterator,next(){if(map._state!==state)throw new Error("LinkedMap got modified during iteration.");if(current){const result={value:current.key,done:!1};return current=current.next,result}return{value:void 0,done:!0}}};return iterator}values(){const map=this,state=this._state;let current=this._head;const iterator={[Symbol.iterator]:()=>iterator,next(){if(map._state!==state)throw new Error("LinkedMap got modified during iteration.");if(current){const result={value:current.value,done:!1};return current=current.next,result}return{value:void 0,done:!0}}};return iterator}entries(){const map=this,state=this._state;let current=this._head;const iterator={[Symbol.iterator]:()=>iterator,next(){if(map._state!==state)throw new Error("LinkedMap got modified during iteration.");if(current){const result={value:[current.key,current.value],done:!1};return current=current.next,result}return{value:void 0,done:!0}}};return iterator}[(_b=Symbol.toStringTag,Symbol.iterator)](){return this.entries()}trimOld(newSize){if(newSize>=this.size)return;if(0===newSize)return void this.clear();let current=this._head,currentSize=this.size;for(;current&&currentSize>newSize;)this._map.delete(current.key),current=current.next,currentSize--;this._head=current,this._size=currentSize,current&&(current.previous=void 0),this._state++}addItemFirst(item){if(this._head||this._tail){if(!this._head)throw new Error("Invalid list");item.next=this._head,this._head.previous=item}else this._tail=item;this._head=item,this._state++}addItemLast(item){if(this._head||this._tail){if(!this._tail)throw new Error("Invalid list");item.previous=this._tail,this._tail.next=item}else this._head=item;this._tail=item,this._state++}removeItem(item){if(item===this._head&&item===this._tail)this._head=void 0,this._tail=void 0;else if(item===this._head){if(!item.next)throw new Error("Invalid list");item.next.previous=void 0,this._head=item.next}else if(item===this._tail){if(!item.previous)throw new Error("Invalid list");item.previous.next=void 0,this._tail=item.previous}else{const next=item.next,previous=item.previous;if(!next||!previous)throw new Error("Invalid list");next.previous=previous,previous.next=next}item.next=void 0,item.previous=void 0,this._state++}touch(item,touch){if(!this._head||!this._tail)throw new Error("Invalid list");if(1===touch||2===touch)if(1===touch){if(item===this._head)return;const next=item.next,previous=item.previous;item===this._tail?(previous.next=void 0,this._tail=previous):(next.previous=previous,previous.next=next),item.previous=void 0,item.next=this._head,this._head.previous=item,this._head=item,this._state++}else if(2===touch){if(item===this._tail)return;const next=item.next,previous=item.previous;item===this._head?(next.previous=void 0,this._head=next):(next.previous=previous,previous.next=next),item.next=void 0,item.previous=this._tail,this._tail.next=item,this._tail=item,this._state++}}toJSON(){const data=[];return this.forEach(((value,key)=>{data.push([key,value])})),data}fromJSON(data){this.clear();for(const[key,value]of data)this.set(key,value)}}export class LRUCache extends LinkedMap{constructor(limit,ratio=1){super(),this._limit=limit,this._ratio=Math.min(Math.max(0,ratio),1)}get limit(){return this._limit}set limit(limit){this._limit=limit,this.checkTrim()}get(key,touch=2){return super.get(key,touch)}peek(key){return super.get(key,0)}set(key,value){return super.set(key,value,2),this.checkTrim(),this}checkTrim(){this.size>this._limit&&this.trimOld(Math.round(this._limit*this._ratio))}}