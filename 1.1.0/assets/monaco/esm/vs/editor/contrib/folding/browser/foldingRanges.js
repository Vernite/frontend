export const MAX_FOLDING_REGIONS=65535;export const MAX_LINE_NUMBER=16777215;const MASK_INDENT=4278190080;class BitField{constructor(size){const numWords=Math.ceil(size/32);this._states=new Uint32Array(numWords)}get(index){const arrayIndex=index/32|0,bit=index%32;return 0!=(this._states[arrayIndex]&1<<bit)}set(index,newState){const arrayIndex=index/32|0,bit=index%32,value=this._states[arrayIndex];this._states[arrayIndex]=newState?value|1<<bit:value&~(1<<bit)}}export class FoldingRegions{constructor(startIndexes,endIndexes,types){if(this.sourceAbbr={0:" ",1:"u",2:"r"},startIndexes.length!==endIndexes.length||startIndexes.length>65535)throw new Error("invalid startIndexes or endIndexes size");this._startIndexes=startIndexes,this._endIndexes=endIndexes,this._collapseStates=new BitField(startIndexes.length),this._userDefinedStates=new BitField(startIndexes.length),this._recoveredStates=new BitField(startIndexes.length),this._types=types,this._parentsComputed=!1}ensureParentIndices(){if(!this._parentsComputed){this._parentsComputed=!0;const parentIndexes=[],isInsideLast=(startLineNumber,endLineNumber)=>{const index=parentIndexes[parentIndexes.length-1];return this.getStartLineNumber(index)<=startLineNumber&&this.getEndLineNumber(index)>=endLineNumber};for(let i=0,len=this._startIndexes.length;i<len;i++){const startLineNumber=this._startIndexes[i],endLineNumber=this._endIndexes[i];if(startLineNumber>16777215||endLineNumber>16777215)throw new Error("startLineNumber or endLineNumber must not exceed 16777215");for(;parentIndexes.length>0&&!isInsideLast(startLineNumber,endLineNumber);)parentIndexes.pop();const parentIndex=parentIndexes.length>0?parentIndexes[parentIndexes.length-1]:-1;parentIndexes.push(i),this._startIndexes[i]=startLineNumber+((255&parentIndex)<<24),this._endIndexes[i]=endLineNumber+((65280&parentIndex)<<16)}}}get length(){return this._startIndexes.length}getStartLineNumber(index){return 16777215&this._startIndexes[index]}getEndLineNumber(index){return 16777215&this._endIndexes[index]}getType(index){return this._types?this._types[index]:void 0}hasTypes(){return!!this._types}isCollapsed(index){return this._collapseStates.get(index)}setCollapsed(index,newState){this._collapseStates.set(index,newState)}isUserDefined(index){return this._userDefinedStates.get(index)}setUserDefined(index,newState){return this._userDefinedStates.set(index,newState)}isRecovered(index){return this._recoveredStates.get(index)}setRecovered(index,newState){return this._recoveredStates.set(index,newState)}getSource(index){return this.isUserDefined(index)?1:this.isRecovered(index)?2:0}setSource(index,source){1===source?(this.setUserDefined(index,!0),this.setRecovered(index,!1)):2===source?(this.setUserDefined(index,!1),this.setRecovered(index,!0)):(this.setUserDefined(index,!1),this.setRecovered(index,!1))}setCollapsedAllOfType(type,newState){let hasChanged=!1;if(this._types)for(let i=0;i<this._types.length;i++)this._types[i]===type&&(this.setCollapsed(i,newState),hasChanged=!0);return hasChanged}toRegion(index){return new FoldingRegion(this,index)}getParentIndex(index){this.ensureParentIndices();const parent=((4278190080&this._startIndexes[index])>>>24)+((4278190080&this._endIndexes[index])>>>16);return 65535===parent?-1:parent}contains(index,line){return this.getStartLineNumber(index)<=line&&this.getEndLineNumber(index)>=line}findIndex(line){let low=0,high=this._startIndexes.length;if(0===high)return-1;for(;low<high;){const mid=Math.floor((low+high)/2);line<this.getStartLineNumber(mid)?high=mid:low=mid+1}return low-1}findRange(line){let index=this.findIndex(line);if(index>=0){if(this.getEndLineNumber(index)>=line)return index;for(index=this.getParentIndex(index);-1!==index;){if(this.contains(index,line))return index;index=this.getParentIndex(index)}}return-1}toString(){const res=[];for(let i=0;i<this.length;i++)res[i]=`[${this.sourceAbbr[this.getSource(i)]}${this.isCollapsed(i)?"+":"-"}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;return res.join(", ")}toFoldRange(index){return{startLineNumber:16777215&this._startIndexes[index],endLineNumber:16777215&this._endIndexes[index],type:this._types?this._types[index]:void 0,isCollapsed:this.isCollapsed(index),source:this.getSource(index)}}static fromFoldRanges(ranges){const rangesLength=ranges.length,startIndexes=new Uint32Array(rangesLength),endIndexes=new Uint32Array(rangesLength);let types=[],gotTypes=!1;for(let i=0;i<rangesLength;i++){const range=ranges[i];startIndexes[i]=range.startLineNumber,endIndexes[i]=range.endLineNumber,types.push(range.type),range.type&&(gotTypes=!0)}gotTypes||(types=void 0);const regions=new FoldingRegions(startIndexes,endIndexes,types);for(let i=0;i<rangesLength;i++)ranges[i].isCollapsed&&regions.setCollapsed(i,!0),regions.setSource(i,ranges[i].source);return regions}static sanitizeAndMerge(rangesA,rangesB,maxLineNumber){maxLineNumber=null!=maxLineNumber?maxLineNumber:Number.MAX_VALUE;const getIndexedFunction=(r,limit)=>Array.isArray(r)?i=>i<limit?r[i]:void 0:i=>i<limit?r.toFoldRange(i):void 0,getA=getIndexedFunction(rangesA,rangesA.length),getB=getIndexedFunction(rangesB,rangesB.length);let indexA=0,indexB=0,nextA=getA(0),nextB=getB(0);const stackedRanges=[];let topStackedRange,prevLineNumber=0;const resultRanges=[];for(;nextA||nextB;){let useRange;if(nextB&&(!nextA||nextA.startLineNumber>=nextB.startLineNumber))nextA&&nextA.startLineNumber===nextB.startLineNumber?(1===nextB.source?useRange=nextB:(useRange=nextA,useRange.isCollapsed=nextB.isCollapsed&&nextA.endLineNumber===nextB.endLineNumber,useRange.source=0),nextA=getA(++indexA)):(useRange=nextB,nextB.isCollapsed&&0===nextB.source&&(useRange.source=2)),nextB=getB(++indexB);else{let scanIndex=indexB,prescanB=nextB;for(;;){if(!prescanB||prescanB.startLineNumber>nextA.endLineNumber){useRange=nextA;break}if(1===prescanB.source&&prescanB.endLineNumber>nextA.endLineNumber)break;prescanB=getB(++scanIndex)}nextA=getA(++indexA)}if(useRange){for(;topStackedRange&&topStackedRange.endLineNumber<useRange.startLineNumber;)topStackedRange=stackedRanges.pop();useRange.endLineNumber>useRange.startLineNumber&&useRange.startLineNumber>prevLineNumber&&useRange.endLineNumber<=maxLineNumber&&(!topStackedRange||topStackedRange.endLineNumber>=useRange.endLineNumber)&&(resultRanges.push(useRange),prevLineNumber=useRange.startLineNumber,topStackedRange&&stackedRanges.push(topStackedRange),topStackedRange=useRange)}}return resultRanges}}export class FoldingRegion{constructor(ranges,index){this.ranges=ranges,this.index=index}get startLineNumber(){return this.ranges.getStartLineNumber(this.index)}get endLineNumber(){return this.ranges.getEndLineNumber(this.index)}get regionIndex(){return this.index}get parentIndex(){return this.ranges.getParentIndex(this.index)}get isCollapsed(){return this.ranges.isCollapsed(this.index)}containedBy(range){return range.startLineNumber<=this.startLineNumber&&range.endLineNumber>=this.endLineNumber}containsLine(lineNumber){return this.startLineNumber<=lineNumber&&lineNumber<=this.endLineNumber}}