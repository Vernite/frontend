import{SingleCursorState}from"../cursorCommon.js";import{CursorColumns}from"../core/cursorColumns.js";import{Position}from"../core/position.js";import{Range}from"../core/range.js";import*as strings from"../../../base/common/strings.js";import{AtomicTabMoveOperations}from"./cursorAtomicMoveOperations.js";export class CursorPosition{constructor(lineNumber,column,leftoverVisibleColumns){this._cursorPositionBrand=void 0,this.lineNumber=lineNumber,this.column=column,this.leftoverVisibleColumns=leftoverVisibleColumns}}export class MoveOperations{static leftPosition(model,position){if(position.column>model.getLineMinColumn(position.lineNumber))return position.delta(void 0,-strings.prevCharLength(model.getLineContent(position.lineNumber),position.column-1));if(position.lineNumber>1){const newLineNumber=position.lineNumber-1;return new Position(newLineNumber,model.getLineMaxColumn(newLineNumber))}return position}static leftPositionAtomicSoftTabs(model,position,tabSize){if(position.column<=model.getLineIndentColumn(position.lineNumber)){const minColumn=model.getLineMinColumn(position.lineNumber),lineContent=model.getLineContent(position.lineNumber),newPosition=AtomicTabMoveOperations.atomicPosition(lineContent,position.column-1,tabSize,0);if(-1!==newPosition&&newPosition+1>=minColumn)return new Position(position.lineNumber,newPosition+1)}return this.leftPosition(model,position)}static left(config,model,position){const pos=config.stickyTabStops?MoveOperations.leftPositionAtomicSoftTabs(model,position,config.tabSize):MoveOperations.leftPosition(model,position);return new CursorPosition(pos.lineNumber,pos.column,0)}static moveLeft(config,model,cursor,inSelectionMode,noOfColumns){let lineNumber,column;if(cursor.hasSelection()&&!inSelectionMode)lineNumber=cursor.selection.startLineNumber,column=cursor.selection.startColumn;else{const pos=cursor.position.delta(void 0,-(noOfColumns-1)),normalizedPos=model.normalizePosition(MoveOperations.clipPositionColumn(pos,model),0),p=MoveOperations.left(config,model,normalizedPos);lineNumber=p.lineNumber,column=p.column}return cursor.move(inSelectionMode,lineNumber,column,0)}static clipPositionColumn(position,model){return new Position(position.lineNumber,MoveOperations.clipRange(position.column,model.getLineMinColumn(position.lineNumber),model.getLineMaxColumn(position.lineNumber)))}static clipRange(value,min,max){return value<min?min:value>max?max:value}static rightPosition(model,lineNumber,column){return column<model.getLineMaxColumn(lineNumber)?column+=strings.nextCharLength(model.getLineContent(lineNumber),column-1):lineNumber<model.getLineCount()&&(lineNumber+=1,column=model.getLineMinColumn(lineNumber)),new Position(lineNumber,column)}static rightPositionAtomicSoftTabs(model,lineNumber,column,tabSize,indentSize){if(column<model.getLineIndentColumn(lineNumber)){const lineContent=model.getLineContent(lineNumber),newPosition=AtomicTabMoveOperations.atomicPosition(lineContent,column-1,tabSize,1);if(-1!==newPosition)return new Position(lineNumber,newPosition+1)}return this.rightPosition(model,lineNumber,column)}static right(config,model,position){const pos=config.stickyTabStops?MoveOperations.rightPositionAtomicSoftTabs(model,position.lineNumber,position.column,config.tabSize,config.indentSize):MoveOperations.rightPosition(model,position.lineNumber,position.column);return new CursorPosition(pos.lineNumber,pos.column,0)}static moveRight(config,model,cursor,inSelectionMode,noOfColumns){let lineNumber,column;if(cursor.hasSelection()&&!inSelectionMode)lineNumber=cursor.selection.endLineNumber,column=cursor.selection.endColumn;else{const pos=cursor.position.delta(void 0,noOfColumns-1),normalizedPos=model.normalizePosition(MoveOperations.clipPositionColumn(pos,model),1),r=MoveOperations.right(config,model,normalizedPos);lineNumber=r.lineNumber,column=r.column}return cursor.move(inSelectionMode,lineNumber,column,0)}static vertical(config,model,lineNumber,column,leftoverVisibleColumns,newLineNumber,allowMoveOnEdgeLine,normalizationAffinity){const currentVisibleColumn=CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber),column,config.tabSize)+leftoverVisibleColumns,lineCount=model.getLineCount(),wasOnFirstPosition=1===lineNumber&&1===column,wasOnLastPosition=lineNumber===lineCount&&column===model.getLineMaxColumn(lineNumber),wasAtEdgePosition=newLineNumber<lineNumber?wasOnFirstPosition:wasOnLastPosition;if((lineNumber=newLineNumber)<1?(lineNumber=1,column=allowMoveOnEdgeLine?model.getLineMinColumn(lineNumber):Math.min(model.getLineMaxColumn(lineNumber),column)):lineNumber>lineCount?(lineNumber=lineCount,column=allowMoveOnEdgeLine?model.getLineMaxColumn(lineNumber):Math.min(model.getLineMaxColumn(lineNumber),column)):column=config.columnFromVisibleColumn(model,lineNumber,currentVisibleColumn),leftoverVisibleColumns=wasAtEdgePosition?0:currentVisibleColumn-CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber),column,config.tabSize),void 0!==normalizationAffinity){const position=new Position(lineNumber,column),newPosition=model.normalizePosition(position,normalizationAffinity);leftoverVisibleColumns+=column-newPosition.column,lineNumber=newPosition.lineNumber,column=newPosition.column}return new CursorPosition(lineNumber,column,leftoverVisibleColumns)}static down(config,model,lineNumber,column,leftoverVisibleColumns,count,allowMoveOnLastLine){return this.vertical(config,model,lineNumber,column,leftoverVisibleColumns,lineNumber+count,allowMoveOnLastLine,4)}static moveDown(config,model,cursor,inSelectionMode,linesCount){let lineNumber,column;cursor.hasSelection()&&!inSelectionMode?(lineNumber=cursor.selection.endLineNumber,column=cursor.selection.endColumn):(lineNumber=cursor.position.lineNumber,column=cursor.position.column);const r=MoveOperations.down(config,model,lineNumber,column,cursor.leftoverVisibleColumns,linesCount,!0);return cursor.move(inSelectionMode,r.lineNumber,r.column,r.leftoverVisibleColumns)}static translateDown(config,model,cursor){const selection=cursor.selection,selectionStart=MoveOperations.down(config,model,selection.selectionStartLineNumber,selection.selectionStartColumn,cursor.selectionStartLeftoverVisibleColumns,1,!1),position=MoveOperations.down(config,model,selection.positionLineNumber,selection.positionColumn,cursor.leftoverVisibleColumns,1,!1);return new SingleCursorState(new Range(selectionStart.lineNumber,selectionStart.column,selectionStart.lineNumber,selectionStart.column),selectionStart.leftoverVisibleColumns,new Position(position.lineNumber,position.column),position.leftoverVisibleColumns)}static up(config,model,lineNumber,column,leftoverVisibleColumns,count,allowMoveOnFirstLine){return this.vertical(config,model,lineNumber,column,leftoverVisibleColumns,lineNumber-count,allowMoveOnFirstLine,3)}static moveUp(config,model,cursor,inSelectionMode,linesCount){let lineNumber,column;cursor.hasSelection()&&!inSelectionMode?(lineNumber=cursor.selection.startLineNumber,column=cursor.selection.startColumn):(lineNumber=cursor.position.lineNumber,column=cursor.position.column);const r=MoveOperations.up(config,model,lineNumber,column,cursor.leftoverVisibleColumns,linesCount,!0);return cursor.move(inSelectionMode,r.lineNumber,r.column,r.leftoverVisibleColumns)}static translateUp(config,model,cursor){const selection=cursor.selection,selectionStart=MoveOperations.up(config,model,selection.selectionStartLineNumber,selection.selectionStartColumn,cursor.selectionStartLeftoverVisibleColumns,1,!1),position=MoveOperations.up(config,model,selection.positionLineNumber,selection.positionColumn,cursor.leftoverVisibleColumns,1,!1);return new SingleCursorState(new Range(selectionStart.lineNumber,selectionStart.column,selectionStart.lineNumber,selectionStart.column),selectionStart.leftoverVisibleColumns,new Position(position.lineNumber,position.column),position.leftoverVisibleColumns)}static _isBlankLine(model,lineNumber){return 0===model.getLineFirstNonWhitespaceColumn(lineNumber)}static moveToPrevBlankLine(config,model,cursor,inSelectionMode){let lineNumber=cursor.position.lineNumber;for(;lineNumber>1&&this._isBlankLine(model,lineNumber);)lineNumber--;for(;lineNumber>1&&!this._isBlankLine(model,lineNumber);)lineNumber--;return cursor.move(inSelectionMode,lineNumber,model.getLineMinColumn(lineNumber),0)}static moveToNextBlankLine(config,model,cursor,inSelectionMode){const lineCount=model.getLineCount();let lineNumber=cursor.position.lineNumber;for(;lineNumber<lineCount&&this._isBlankLine(model,lineNumber);)lineNumber++;for(;lineNumber<lineCount&&!this._isBlankLine(model,lineNumber);)lineNumber++;return cursor.move(inSelectionMode,lineNumber,model.getLineMinColumn(lineNumber),0)}static moveToBeginningOfLine(config,model,cursor,inSelectionMode){const lineNumber=cursor.position.lineNumber,minColumn=model.getLineMinColumn(lineNumber),firstNonBlankColumn=model.getLineFirstNonWhitespaceColumn(lineNumber)||minColumn;let column;return column=cursor.position.column===firstNonBlankColumn?minColumn:firstNonBlankColumn,cursor.move(inSelectionMode,lineNumber,column,0)}static moveToEndOfLine(config,model,cursor,inSelectionMode,sticky){const lineNumber=cursor.position.lineNumber,maxColumn=model.getLineMaxColumn(lineNumber);return cursor.move(inSelectionMode,lineNumber,maxColumn,sticky?1073741824-maxColumn:0)}static moveToBeginningOfBuffer(config,model,cursor,inSelectionMode){return cursor.move(inSelectionMode,1,1,0)}static moveToEndOfBuffer(config,model,cursor,inSelectionMode){const lastLineNumber=model.getLineCount(),lastColumn=model.getLineMaxColumn(lastLineNumber);return cursor.move(inSelectionMode,lastLineNumber,lastColumn,0)}}