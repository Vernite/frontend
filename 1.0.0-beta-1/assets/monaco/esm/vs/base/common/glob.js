var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):function adopt(value){return value instanceof P?value:new P((function(resolve){resolve(value)}))}(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))};import{isThenable}from"./async.js";import{isEqualOrParent}from"./extpath.js";import{LRUCache}from"./map.js";import{basename,extname,posix,sep}from"./path.js";import{isLinux}from"./platform.js";import{escapeRegExpCharacters}from"./strings.js";export const GLOBSTAR="**";export const GLOB_SPLIT="/";const PATH_REGEX="[/\\\\]",NO_PATH_REGEX="[^/\\\\]",ALL_FORWARD_SLASHES=/\//g;function starsToRegExp(starCount,isLastPattern){switch(starCount){case 0:return"";case 1:return"[^/\\\\]*?";default:return`(?:[/\\\\]|[^/\\\\]+[/\\\\]${isLastPattern?"|[/\\\\][^/\\\\]+":""})*?`}}export function splitGlobAware(pattern,splitChar){if(!pattern)return[];const segments=[];let inBraces=!1,inBrackets=!1,curVal="";for(const char of pattern){switch(char){case splitChar:if(!inBraces&&!inBrackets){segments.push(curVal),curVal="";continue}break;case"{":inBraces=!0;break;case"}":inBraces=!1;break;case"[":inBrackets=!0;break;case"]":inBrackets=!1}curVal+=char}return curVal&&segments.push(curVal),segments}function parseRegExp(pattern){if(!pattern)return"";let regEx="";const segments=splitGlobAware(pattern,"/");if(segments.every((segment=>"**"===segment)))regEx=".*";else{let previousSegmentWasGlobStar=!1;segments.forEach(((segment,index)=>{if("**"===segment){if(previousSegmentWasGlobStar)return;regEx+=starsToRegExp(2,index===segments.length-1)}else{let inBraces=!1,braceVal="",inBrackets=!1,bracketVal="";for(const char of segment)if("}"!==char&&inBraces)braceVal+=char;else if(!inBrackets||"]"===char&&bracketVal)switch(char){case"{":inBraces=!0;continue;case"[":inBrackets=!0;continue;case"}":{const braceRegExp=`(?:${splitGlobAware(braceVal,",").map((choice=>parseRegExp(choice))).join("|")})`;regEx+=braceRegExp,inBraces=!1,braceVal="";break}case"]":regEx+="["+bracketVal+"]",inBrackets=!1,bracketVal="";break;case"?":regEx+="[^/\\\\]";continue;case"*":regEx+=starsToRegExp(1);continue;default:regEx+=escapeRegExpCharacters(char)}else{let res;res="-"===char?char:"^"!==char&&"!"!==char||bracketVal?"/"===char?"":escapeRegExpCharacters(char):"^",bracketVal+=res}index<segments.length-1&&("**"!==segments[index+1]||index+2<segments.length)&&(regEx+="[/\\\\]")}previousSegmentWasGlobStar="**"===segment}))}return regEx}const T1=/^\*\*\/\*\.[\w\.-]+$/,T2=/^\*\*\/([\w\.-]+)\/?$/,T3=/^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/,T3_2=/^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/,T4=/^\*\*((\/[\w\.-]+)+)\/?$/,T5=/^([\w\.-]+(\/[\w\.-]+)*)\/?$/,CACHE=new LRUCache(1e4),FALSE=function(){return!1},NULL=function(){return null};function parsePattern(arg1,options){if(!arg1)return NULL;let pattern;pattern="string"!=typeof arg1?arg1.pattern:arg1,pattern=pattern.trim();const patternKey=`${pattern}_${!!options.trimForExclusions}`;let match,parsedPattern=CACHE.get(patternKey);return parsedPattern||(parsedPattern=T1.test(pattern)?trivia1(pattern.substr(4),pattern):(match=T2.exec(trimForExclusions(pattern,options)))?trivia2(match[1],pattern):(options.trimForExclusions?T3_2:T3).test(pattern)?trivia3(pattern,options):(match=T4.exec(trimForExclusions(pattern,options)))?trivia4and5(match[1].substr(1),pattern,!0):(match=T5.exec(trimForExclusions(pattern,options)))?trivia4and5(match[1],pattern,!1):toRegExp(pattern),CACHE.set(patternKey,parsedPattern)),wrapRelativePattern(parsedPattern,arg1)}function wrapRelativePattern(parsedPattern,arg2){if("string"==typeof arg2)return parsedPattern;const wrappedPattern=function(path,basename){return isEqualOrParent(path,arg2.base,!isLinux)?parsedPattern(path.substr(arg2.base.length+1),basename):null};return wrappedPattern.allBasenames=parsedPattern.allBasenames,wrappedPattern.allPaths=parsedPattern.allPaths,wrappedPattern.basenames=parsedPattern.basenames,wrappedPattern.patterns=parsedPattern.patterns,wrappedPattern}function trimForExclusions(pattern,options){return options.trimForExclusions&&pattern.endsWith("/**")?pattern.substr(0,pattern.length-2):pattern}function trivia1(base,pattern){return function(path,basename){return"string"==typeof path&&path.endsWith(base)?pattern:null}}function trivia2(base,pattern){const slashBase=`/${base}`,backslashBase=`\\${base}`,parsedPattern=function(path,basename){return"string"!=typeof path?null:basename?basename===base?pattern:null:path===base||path.endsWith(slashBase)||path.endsWith(backslashBase)?pattern:null},basenames=[base];return parsedPattern.basenames=basenames,parsedPattern.patterns=[pattern],parsedPattern.allBasenames=basenames,parsedPattern}function trivia3(pattern,options){const parsedPatterns=aggregateBasenameMatches(pattern.slice(1,-1).split(",").map((pattern=>parsePattern(pattern,options))).filter((pattern=>pattern!==NULL)),pattern),patternsLength=parsedPatterns.length;if(!patternsLength)return NULL;if(1===patternsLength)return parsedPatterns[0];const parsedPattern=function(path,basename){for(let i=0,n=parsedPatterns.length;i<n;i++)if(parsedPatterns[i](path,basename))return pattern;return null},withBasenames=parsedPatterns.find((pattern=>!!pattern.allBasenames));withBasenames&&(parsedPattern.allBasenames=withBasenames.allBasenames);const allPaths=parsedPatterns.reduce(((all,current)=>current.allPaths?all.concat(current.allPaths):all),[]);return allPaths.length&&(parsedPattern.allPaths=allPaths),parsedPattern}function trivia4and5(targetPath,pattern,matchPathEnds){const usingPosixSep=sep===posix.sep,nativePath=usingPosixSep?targetPath:targetPath.replace(ALL_FORWARD_SLASHES,sep),nativePathEnd=sep+nativePath,targetPathEnd=posix.sep+targetPath;let parsedPattern;return parsedPattern=matchPathEnds?function(path,basename){return"string"!=typeof path||path!==nativePath&&!path.endsWith(nativePathEnd)&&(usingPosixSep||path!==targetPath&&!path.endsWith(targetPathEnd))?null:pattern}:function(path,basename){return"string"!=typeof path||path!==nativePath&&(usingPosixSep||path!==targetPath)?null:pattern},parsedPattern.allPaths=[(matchPathEnds?"*/":"./")+targetPath],parsedPattern}function toRegExp(pattern){try{const regExp=new RegExp(`^${parseRegExp(pattern)}$`);return function(path){return regExp.lastIndex=0,"string"==typeof path&&regExp.test(path)?pattern:null}}catch(error){return NULL}}export function match(arg1,path,hasSibling){return!(!arg1||"string"!=typeof path)&&parse(arg1)(path,void 0,hasSibling)}export function parse(arg1,options={}){if(!arg1)return FALSE;if("string"==typeof arg1||isRelativePattern(arg1)){const parsedPattern=parsePattern(arg1,options);if(parsedPattern===NULL)return FALSE;const resultPattern=function(path,basename){return!!parsedPattern(path,basename)};return parsedPattern.allBasenames&&(resultPattern.allBasenames=parsedPattern.allBasenames),parsedPattern.allPaths&&(resultPattern.allPaths=parsedPattern.allPaths),resultPattern}return parsedExpression(arg1,options)}export function isRelativePattern(obj){const rp=obj;return!!rp&&("string"==typeof rp.base&&"string"==typeof rp.pattern)}function parsedExpression(expression,options){const parsedPatterns=aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map((pattern=>parseExpressionPattern(pattern,expression[pattern],options))).filter((pattern=>pattern!==NULL))),patternsLength=parsedPatterns.length;if(!patternsLength)return NULL;if(!parsedPatterns.some((parsedPattern=>!!parsedPattern.requiresSiblings))){if(1===patternsLength)return parsedPatterns[0];const resultExpression=function(path,basename){let resultPromises;for(let i=0,n=parsedPatterns.length;i<n;i++){const result=parsedPatterns[i](path,basename);if("string"==typeof result)return result;isThenable(result)&&(resultPromises||(resultPromises=[]),resultPromises.push(result))}return resultPromises?(()=>__awaiter(this,void 0,void 0,(function*(){for(const resultPromise of resultPromises){const result=yield resultPromise;if("string"==typeof result)return result}return null})))():null},withBasenames=parsedPatterns.find((pattern=>!!pattern.allBasenames));withBasenames&&(resultExpression.allBasenames=withBasenames.allBasenames);const allPaths=parsedPatterns.reduce(((all,current)=>current.allPaths?all.concat(current.allPaths):all),[]);return allPaths.length&&(resultExpression.allPaths=allPaths),resultExpression}const resultExpression=function(path,base,hasSibling){let name,resultPromises;for(let i=0,n=parsedPatterns.length;i<n;i++){const parsedPattern=parsedPatterns[i];parsedPattern.requiresSiblings&&hasSibling&&(base||(base=basename(path)),name||(name=base.substr(0,base.length-extname(path).length)));const result=parsedPattern(path,base,name,hasSibling);if("string"==typeof result)return result;isThenable(result)&&(resultPromises||(resultPromises=[]),resultPromises.push(result))}return resultPromises?(()=>__awaiter(this,void 0,void 0,(function*(){for(const resultPromise of resultPromises){const result=yield resultPromise;if("string"==typeof result)return result}return null})))():null},withBasenames=parsedPatterns.find((pattern=>!!pattern.allBasenames));withBasenames&&(resultExpression.allBasenames=withBasenames.allBasenames);const allPaths=parsedPatterns.reduce(((all,current)=>current.allPaths?all.concat(current.allPaths):all),[]);return allPaths.length&&(resultExpression.allPaths=allPaths),resultExpression}function parseExpressionPattern(pattern,value,options){if(!1===value)return NULL;const parsedPattern=parsePattern(pattern,options);if(parsedPattern===NULL)return NULL;if("boolean"==typeof value)return parsedPattern;if(value){const when=value.when;if("string"==typeof when){const result=(path,basename,name,hasSibling)=>{if(!hasSibling||!parsedPattern(path,basename))return null;const matched=hasSibling(when.replace("$(basename)",name));return isThenable(matched)?matched.then((match=>match?pattern:null)):matched?pattern:null};return result.requiresSiblings=!0,result}}return parsedPattern}function aggregateBasenameMatches(parsedPatterns,result){const basenamePatterns=parsedPatterns.filter((parsedPattern=>!!parsedPattern.basenames));if(basenamePatterns.length<2)return parsedPatterns;const basenames=basenamePatterns.reduce(((all,current)=>{const basenames=current.basenames;return basenames?all.concat(basenames):all}),[]);let patterns;if(result){patterns=[];for(let i=0,n=basenames.length;i<n;i++)patterns.push(result)}else patterns=basenamePatterns.reduce(((all,current)=>{const patterns=current.patterns;return patterns?all.concat(patterns):all}),[]);const aggregate=function(path,basename){if("string"!=typeof path)return null;if(!basename){let i;for(i=path.length;i>0;i--){const ch=path.charCodeAt(i-1);if(47===ch||92===ch)break}basename=path.substr(i)}const index=basenames.indexOf(basename);return-1!==index?patterns[index]:null};aggregate.basenames=basenames,aggregate.patterns=patterns,aggregate.allBasenames=basenames;const aggregatedPatterns=parsedPatterns.filter((parsedPattern=>!parsedPattern.basenames));return aggregatedPatterns.push(aggregate),aggregatedPatterns}