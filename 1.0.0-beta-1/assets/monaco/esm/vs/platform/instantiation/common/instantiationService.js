import{IdleValue}from"../../../base/common/async.js";import{illegalState}from"../../../base/common/errors.js";import{SyncDescriptor}from"./descriptors.js";import{Graph}from"./graph.js";import{IInstantiationService,_util}from"./instantiation.js";import{ServiceCollection}from"./serviceCollection.js";const _enableTracing=!1;class CyclicDependencyError extends Error{constructor(graph){var _a;super("cyclic dependency between services"),this.message=null!==(_a=graph.findCycleSlow())&&void 0!==_a?_a:`UNABLE to detect cycle, dumping graph: \n${graph.toString()}`}}export class InstantiationService{constructor(services=new ServiceCollection,strict=!1,parent){this._activeInstantiations=new Set,this._services=services,this._strict=strict,this._parent=parent,this._services.set(IInstantiationService,this)}createChild(services){return new InstantiationService(services,this._strict,this)}invokeFunction(fn,...args){const _trace=Trace.traceInvocation(fn);let _done=!1;try{return fn({get:id=>{if(_done)throw illegalState("service accessor is only valid during the invocation of its target method");const result=this._getOrCreateServiceInstance(id,_trace);if(!result)throw new Error(`[invokeFunction] unknown service '${id}'`);return result}},...args)}finally{_done=!0,_trace.stop()}}createInstance(ctorOrDescriptor,...rest){let _trace,result;return ctorOrDescriptor instanceof SyncDescriptor?(_trace=Trace.traceCreation(ctorOrDescriptor.ctor),result=this._createInstance(ctorOrDescriptor.ctor,ctorOrDescriptor.staticArguments.concat(rest),_trace)):(_trace=Trace.traceCreation(ctorOrDescriptor),result=this._createInstance(ctorOrDescriptor,rest,_trace)),_trace.stop(),result}_createInstance(ctor,args=[],_trace){const serviceDependencies=_util.getServiceDependencies(ctor).sort(((a,b)=>a.index-b.index)),serviceArgs=[];for(const dependency of serviceDependencies){const service=this._getOrCreateServiceInstance(dependency.id,_trace);service||this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`,!1),serviceArgs.push(service)}const firstServiceArgPos=serviceDependencies.length>0?serviceDependencies[0].index:args.length;if(args.length!==firstServiceArgPos){console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos+1} conflicts with ${args.length} static arguments`);const delta=firstServiceArgPos-args.length;args=delta>0?args.concat(new Array(delta)):args.slice(0,firstServiceArgPos)}return new ctor(...[...args,...serviceArgs])}_setServiceInstance(id,instance){if(this._services.get(id)instanceof SyncDescriptor)this._services.set(id,instance);else{if(!this._parent)throw new Error("illegalState - setting UNKNOWN service instance");this._parent._setServiceInstance(id,instance)}}_getServiceInstanceOrDescriptor(id){const instanceOrDesc=this._services.get(id);return!instanceOrDesc&&this._parent?this._parent._getServiceInstanceOrDescriptor(id):instanceOrDesc}_getOrCreateServiceInstance(id,_trace){const thing=this._getServiceInstanceOrDescriptor(id);return thing instanceof SyncDescriptor?this._safeCreateAndCacheServiceInstance(id,thing,_trace.branch(id,!0)):(_trace.branch(id,!1),thing)}_safeCreateAndCacheServiceInstance(id,desc,_trace){if(this._activeInstantiations.has(id))throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);this._activeInstantiations.add(id);try{return this._createAndCacheServiceInstance(id,desc,_trace)}finally{this._activeInstantiations.delete(id)}}_createAndCacheServiceInstance(id,desc,_trace){const graph=new Graph((data=>data.id.toString()));let cycleCount=0;const stack=[{id,desc,_trace}];for(;stack.length;){const item=stack.pop();if(graph.lookupOrInsertNode(item),cycleCount++>1e3)throw new CyclicDependencyError(graph);for(const dependency of _util.getServiceDependencies(item.desc.ctor)){const instanceOrDesc=this._getServiceInstanceOrDescriptor(dependency.id);if(instanceOrDesc||this._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`,!0),instanceOrDesc instanceof SyncDescriptor){const d={id:dependency.id,desc:instanceOrDesc,_trace:item._trace.branch(dependency.id,!0)};graph.insertEdge(item,d),stack.push(d)}}}for(;;){const roots=graph.roots();if(0===roots.length){if(!graph.isEmpty())throw new CyclicDependencyError(graph);break}for(const{data}of roots){if(this._getServiceInstanceOrDescriptor(data.id)instanceof SyncDescriptor){const instance=this._createServiceInstanceWithOwner(data.id,data.desc.ctor,data.desc.staticArguments,data.desc.supportsDelayedInstantiation,data._trace);this._setServiceInstance(data.id,instance)}graph.removeNode(data)}}return this._getServiceInstanceOrDescriptor(id)}_createServiceInstanceWithOwner(id,ctor,args=[],supportsDelayedInstantiation,_trace){if(this._services.get(id)instanceof SyncDescriptor)return this._createServiceInstance(ctor,args,supportsDelayedInstantiation,_trace);if(this._parent)return this._parent._createServiceInstanceWithOwner(id,ctor,args,supportsDelayedInstantiation,_trace);throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`)}_createServiceInstance(ctor,args=[],_supportsDelayedInstantiation,_trace){if(_supportsDelayedInstantiation){const idle=new IdleValue((()=>this._createInstance(ctor,args,_trace)));return new Proxy(Object.create(null),{get(target,key){if(key in target)return target[key];const obj=idle.value;let prop=obj[key];return"function"!=typeof prop||(prop=prop.bind(obj),target[key]=prop),prop},set:(_target,p,value)=>(idle.value[p]=value,!0)})}return this._createInstance(ctor,args,_trace)}_throwIfStrict(msg,printWarning){if(printWarning&&console.warn(msg),this._strict)throw new Error(msg)}}export class Trace{constructor(type,name){this.type=type,this.name=name,this._start=Date.now(),this._dep=[]}static traceInvocation(ctor){return Trace._None}static traceCreation(ctor){return Trace._None}branch(id,first){const child=new Trace(2,id.toString());return this._dep.push([id,first,child]),child}stop(){const dur=Date.now()-this._start;Trace._totals+=dur;let causedCreation=!1;const lines=[`${0===this.type?"CREATE":"CALL"} ${this.name}`,`${function printChild(n,trace){const res=[],prefix=new Array(n+1).join("\t");for(const[id,first,child]of trace._dep)if(first&&child){causedCreation=!0,res.push(`${prefix}CREATES -> ${id}`);const nested=printChild(n+1,child);nested&&res.push(nested)}else res.push(`${prefix}uses -> ${id}`);return res.join("\n")}(1,this)}`,`DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`];(dur>2||causedCreation)&&console.log(lines.join("\n"))}}Trace._None=new class extends Trace{constructor(){super(-1,null)}stop(){}branch(){return this}},Trace._totals=0;