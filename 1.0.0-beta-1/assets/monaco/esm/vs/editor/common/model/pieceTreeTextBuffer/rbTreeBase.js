export class TreeNode{constructor(piece,color){this.piece=piece,this.color=color,this.size_left=0,this.lf_left=0,this.parent=this,this.left=this,this.right=this}next(){if(this.right!==SENTINEL)return leftest(this.right);let node=this;for(;node.parent!==SENTINEL&&node.parent.left!==node;)node=node.parent;return node.parent===SENTINEL?SENTINEL:node.parent}prev(){if(this.left!==SENTINEL)return righttest(this.left);let node=this;for(;node.parent!==SENTINEL&&node.parent.right!==node;)node=node.parent;return node.parent===SENTINEL?SENTINEL:node.parent}detach(){this.parent=null,this.left=null,this.right=null}}export const SENTINEL=new TreeNode(null,0);SENTINEL.parent=SENTINEL,SENTINEL.left=SENTINEL,SENTINEL.right=SENTINEL,SENTINEL.color=0;export function leftest(node){for(;node.left!==SENTINEL;)node=node.left;return node}export function righttest(node){for(;node.right!==SENTINEL;)node=node.right;return node}export function calculateSize(node){return node===SENTINEL?0:node.size_left+node.piece.length+calculateSize(node.right)}export function calculateLF(node){return node===SENTINEL?0:node.lf_left+node.piece.lineFeedCnt+calculateLF(node.right)}export function resetSentinel(){SENTINEL.parent=SENTINEL}export function leftRotate(tree,x){const y=x.right;y.size_left+=x.size_left+(x.piece?x.piece.length:0),y.lf_left+=x.lf_left+(x.piece?x.piece.lineFeedCnt:0),x.right=y.left,y.left!==SENTINEL&&(y.left.parent=x),y.parent=x.parent,x.parent===SENTINEL?tree.root=y:x.parent.left===x?x.parent.left=y:x.parent.right=y,y.left=x,x.parent=y}export function rightRotate(tree,y){const x=y.left;y.left=x.right,x.right!==SENTINEL&&(x.right.parent=y),x.parent=y.parent,y.size_left-=x.size_left+(x.piece?x.piece.length:0),y.lf_left-=x.lf_left+(x.piece?x.piece.lineFeedCnt:0),y.parent===SENTINEL?tree.root=x:y===y.parent.right?y.parent.right=x:y.parent.left=x,x.right=y,y.parent=x}export function rbDelete(tree,z){let x,y;if(z.left===SENTINEL?(y=z,x=y.right):z.right===SENTINEL?(y=z,x=y.left):(y=leftest(z.right),x=y.right),y===tree.root)return tree.root=x,x.color=0,z.detach(),resetSentinel(),void(tree.root.parent=SENTINEL);const yWasRed=1===y.color;if(y===y.parent.left?y.parent.left=x:y.parent.right=x,y===z?(x.parent=y.parent,recomputeTreeMetadata(tree,x)):(y.parent===z?x.parent=y:x.parent=y.parent,recomputeTreeMetadata(tree,x),y.left=z.left,y.right=z.right,y.parent=z.parent,y.color=z.color,z===tree.root?tree.root=y:z===z.parent.left?z.parent.left=y:z.parent.right=y,y.left!==SENTINEL&&(y.left.parent=y),y.right!==SENTINEL&&(y.right.parent=y),y.size_left=z.size_left,y.lf_left=z.lf_left,recomputeTreeMetadata(tree,y)),z.detach(),x.parent.left===x){const newSizeLeft=calculateSize(x),newLFLeft=calculateLF(x);if(newSizeLeft!==x.parent.size_left||newLFLeft!==x.parent.lf_left){const delta=newSizeLeft-x.parent.size_left,lf_delta=newLFLeft-x.parent.lf_left;x.parent.size_left=newSizeLeft,x.parent.lf_left=newLFLeft,updateTreeMetadata(tree,x.parent,delta,lf_delta)}}if(recomputeTreeMetadata(tree,x.parent),yWasRed)return void resetSentinel();let w;for(;x!==tree.root&&0===x.color;)x===x.parent.left?(w=x.parent.right,1===w.color&&(w.color=0,x.parent.color=1,leftRotate(tree,x.parent),w=x.parent.right),0===w.left.color&&0===w.right.color?(w.color=1,x=x.parent):(0===w.right.color&&(w.left.color=0,w.color=1,rightRotate(tree,w),w=x.parent.right),w.color=x.parent.color,x.parent.color=0,w.right.color=0,leftRotate(tree,x.parent),x=tree.root)):(w=x.parent.left,1===w.color&&(w.color=0,x.parent.color=1,rightRotate(tree,x.parent),w=x.parent.left),0===w.left.color&&0===w.right.color?(w.color=1,x=x.parent):(0===w.left.color&&(w.right.color=0,w.color=1,leftRotate(tree,w),w=x.parent.left),w.color=x.parent.color,x.parent.color=0,w.left.color=0,rightRotate(tree,x.parent),x=tree.root));x.color=0,resetSentinel()}export function fixInsert(tree,x){for(recomputeTreeMetadata(tree,x);x!==tree.root&&1===x.parent.color;)if(x.parent===x.parent.parent.left){const y=x.parent.parent.right;1===y.color?(x.parent.color=0,y.color=0,x.parent.parent.color=1,x=x.parent.parent):(x===x.parent.right&&leftRotate(tree,x=x.parent),x.parent.color=0,x.parent.parent.color=1,rightRotate(tree,x.parent.parent))}else{const y=x.parent.parent.left;1===y.color?(x.parent.color=0,y.color=0,x.parent.parent.color=1,x=x.parent.parent):(x===x.parent.left&&rightRotate(tree,x=x.parent),x.parent.color=0,x.parent.parent.color=1,leftRotate(tree,x.parent.parent))}tree.root.color=0}export function updateTreeMetadata(tree,x,delta,lineFeedCntDelta){for(;x!==tree.root&&x!==SENTINEL;)x.parent.left===x&&(x.parent.size_left+=delta,x.parent.lf_left+=lineFeedCntDelta),x=x.parent}export function recomputeTreeMetadata(tree,x){let delta=0,lf_delta=0;if(x!==tree.root){for(;x!==tree.root&&x===x.parent.right;)x=x.parent;if(x!==tree.root)for(delta=calculateSize((x=x.parent).left)-x.size_left,lf_delta=calculateLF(x.left)-x.lf_left,x.size_left+=delta,x.lf_left+=lf_delta;x!==tree.root&&(0!==delta||0!==lf_delta);)x.parent.left===x&&(x.parent.size_left+=delta,x.parent.lf_left+=lf_delta),x=x.parent}}