import*as monarchCommon from"./monarchCommon.js";function isArrayOf(elemType,obj){if(!obj)return!1;if(!Array.isArray(obj))return!1;for(const el of obj)if(!elemType(el))return!1;return!0}function bool(prop,defValue){return"boolean"==typeof prop?prop:defValue}function string(prop,defValue){return"string"==typeof prop?prop:defValue}function arrayToHash(array){const result={};for(const e of array)result[e]=!0;return result}function createKeywordMatcher(arr,caseInsensitive=!1){caseInsensitive&&(arr=arr.map((function(x){return x.toLowerCase()})));const hash=arrayToHash(arr);return caseInsensitive?function(word){return void 0!==hash[word.toLowerCase()]&&hash.hasOwnProperty(word.toLowerCase())}:function(word){return void 0!==hash[word]&&hash.hasOwnProperty(word)}}function compileRegExp(lexer,str){str=str.replace(/@@/g,"");let hadExpansion,n=0;do{hadExpansion=!1,str=str.replace(/@(\w+)/g,(function(s,attr){hadExpansion=!0;let sub="";if("string"==typeof lexer[attr])sub=lexer[attr];else{if(!(lexer[attr]&&lexer[attr]instanceof RegExp))throw void 0===lexer[attr]?monarchCommon.createError(lexer,"language definition does not contain attribute '"+attr+"', used at: "+str):monarchCommon.createError(lexer,"attribute reference '"+attr+"' must be a string, used at: "+str);sub=lexer[attr].source}return monarchCommon.empty(sub)?"":"(?:"+sub+")"})),n++}while(hadExpansion&&n<5);str=str.replace(/\x01/g,"@");const flags=(lexer.ignoreCase?"i":"")+(lexer.unicode?"u":"");return new RegExp(str,flags)}function selectScrutinee(id,matches,state,num){if(num<0)return id;if(num<matches.length)return matches[num];if(num>=100){num-=100;const parts=state.split(".");if(parts.unshift(state),num<parts.length)return parts[num]}return null}function createGuard(lexer,ruleName,tkey,val){let scrut=-1,oppat=tkey,matches=tkey.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);matches&&(matches[3]&&(scrut=parseInt(matches[3]),matches[2]&&(scrut+=100)),oppat=matches[4]);let tester,op="~",pat=oppat;if(oppat&&0!==oppat.length?/^\w*$/.test(pat)?op="==":(matches=oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/),matches&&(op=matches[1],pat=matches[2])):(op="!=",pat=""),"~"!==op&&"!~"!==op||!/^(\w|\|)*$/.test(pat))if("@"===op||"!@"===op){const words=lexer[pat];if(!words)throw monarchCommon.createError(lexer,"the @ match target '"+pat+"' is not defined, in rule: "+ruleName);if(!isArrayOf((function(elem){return"string"==typeof elem}),words))throw monarchCommon.createError(lexer,"the @ match target '"+pat+"' must be an array of strings, in rule: "+ruleName);const inWords=createKeywordMatcher(words,lexer.ignoreCase);tester=function(s){return"@"===op?inWords(s):!inWords(s)}}else if("~"===op||"!~"===op)if(pat.indexOf("$")<0){const re=compileRegExp(lexer,"^"+pat+"$");tester=function(s){return"~"===op?re.test(s):!re.test(s)}}else tester=function(s,id,matches,state){return compileRegExp(lexer,"^"+monarchCommon.substituteMatches(lexer,pat,id,matches,state)+"$").test(s)};else if(pat.indexOf("$")<0){const patx=monarchCommon.fixCase(lexer,pat);tester=function(s){return"=="===op?s===patx:s!==patx}}else{const patx=monarchCommon.fixCase(lexer,pat);tester=function(s,id,matches,state,eos){const patexp=monarchCommon.substituteMatches(lexer,patx,id,matches,state);return"=="===op?s===patexp:s!==patexp}}else{const inWords=createKeywordMatcher(pat.split("|"),lexer.ignoreCase);tester=function(s){return"~"===op?inWords(s):!inWords(s)}}return-1===scrut?{name:tkey,value:val,test:function(id,matches,state,eos){return tester(id,id,matches,state,eos)}}:{name:tkey,value:val,test:function(id,matches,state,eos){const scrutinee=selectScrutinee(id,matches,state,scrut);return tester(scrutinee||"",id,matches,state,eos)}}}function compileAction(lexer,ruleName,action){if(action){if("string"==typeof action)return action;if(action.token||""===action.token){if("string"!=typeof action.token)throw monarchCommon.createError(lexer,"a 'token' attribute must be of type string, in rule: "+ruleName);{const newAction={token:action.token};if(action.token.indexOf("$")>=0&&(newAction.tokenSubst=!0),"string"==typeof action.bracket)if("@open"===action.bracket)newAction.bracket=1;else{if("@close"!==action.bracket)throw monarchCommon.createError(lexer,"a 'bracket' attribute must be either '@open' or '@close', in rule: "+ruleName);newAction.bracket=-1}if(action.next){if("string"!=typeof action.next)throw monarchCommon.createError(lexer,"the next state must be a string value in rule: "+ruleName);{let next=action.next;if(!/^(@pop|@push|@popall)$/.test(next)&&("@"===next[0]&&(next=next.substr(1)),next.indexOf("$")<0&&!monarchCommon.stateExists(lexer,monarchCommon.substituteMatches(lexer,next,"",[],""))))throw monarchCommon.createError(lexer,"the next state '"+action.next+"' is not defined in rule: "+ruleName);newAction.next=next}}return"number"==typeof action.goBack&&(newAction.goBack=action.goBack),"string"==typeof action.switchTo&&(newAction.switchTo=action.switchTo),"string"==typeof action.log&&(newAction.log=action.log),"string"==typeof action.nextEmbedded&&(newAction.nextEmbedded=action.nextEmbedded,lexer.usesEmbedded=!0),newAction}}if(Array.isArray(action)){const results=[];for(let i=0,len=action.length;i<len;i++)results[i]=compileAction(lexer,ruleName,action[i]);return{group:results}}if(action.cases){const cases=[];for(const tkey in action.cases)if(action.cases.hasOwnProperty(tkey)){const val=compileAction(lexer,ruleName,action.cases[tkey]);"@default"===tkey||"@"===tkey||""===tkey?cases.push({test:void 0,value:val,name:tkey}):"@eos"===tkey?cases.push({test:function(id,matches,state,eos){return eos},value:val,name:tkey}):cases.push(createGuard(lexer,ruleName,tkey,val))}const def=lexer.defaultToken;return{test:function(id,matches,state,eos){for(const _case of cases){if(!_case.test||_case.test(id,matches,state,eos))return _case.value}return def}}}throw monarchCommon.createError(lexer,"an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: "+ruleName)}return{token:""}}class Rule{constructor(name){this.regex=new RegExp(""),this.action={token:""},this.matchOnlyAtLineStart=!1,this.name="",this.name=name}setRegex(lexer,re){let sregex;if("string"==typeof re)sregex=re;else{if(!(re instanceof RegExp))throw monarchCommon.createError(lexer,"rules must start with a match string or regular expression: "+this.name);sregex=re.source}this.matchOnlyAtLineStart=sregex.length>0&&"^"===sregex[0],this.name=this.name+": "+sregex,this.regex=compileRegExp(lexer,"^(?:"+(this.matchOnlyAtLineStart?sregex.substr(1):sregex)+")")}setAction(lexer,act){this.action=compileAction(lexer,this.name,act)}}export function compile(languageId,json){if(!json||"object"!=typeof json)throw new Error("Monarch: expecting a language definition object");const lexer={};lexer.languageId=languageId,lexer.includeLF=bool(json.includeLF,!1),lexer.noThrow=!1,lexer.maxStack=100,lexer.start="string"==typeof json.start?json.start:null,lexer.ignoreCase=bool(json.ignoreCase,!1),lexer.unicode=bool(json.unicode,!1),lexer.tokenPostfix=string(json.tokenPostfix,"."+lexer.languageId),lexer.defaultToken=string(json.defaultToken,"source"),lexer.usesEmbedded=!1;const lexerMin=json;function addRules(state,newrules,rules){for(const rule of rules){let include=rule.include;if(include){if("string"!=typeof include)throw monarchCommon.createError(lexer,"an 'include' attribute must be a string at: "+state);if("@"===include[0]&&(include=include.substr(1)),!json.tokenizer[include])throw monarchCommon.createError(lexer,"include target '"+include+"' is not defined at: "+state);addRules(state+"."+include,newrules,json.tokenizer[include])}else{const newrule=new Rule(state);if(Array.isArray(rule)&&rule.length>=1&&rule.length<=3)if(newrule.setRegex(lexerMin,rule[0]),rule.length>=3)if("string"==typeof rule[1])newrule.setAction(lexerMin,{token:rule[1],next:rule[2]});else{if("object"!=typeof rule[1])throw monarchCommon.createError(lexer,"a next state as the last element of a rule can only be given if the action is either an object or a string, at: "+state);{const rule1=rule[1];rule1.next=rule[2],newrule.setAction(lexerMin,rule1)}}else newrule.setAction(lexerMin,rule[1]);else{if(!rule.regex)throw monarchCommon.createError(lexer,"a rule must either be an array, or an object with a 'regex' or 'include' field at: "+state);rule.name&&"string"==typeof rule.name&&(newrule.name=rule.name),rule.matchOnlyAtStart&&(newrule.matchOnlyAtLineStart=bool(rule.matchOnlyAtLineStart,!1)),newrule.setRegex(lexerMin,rule.regex),newrule.setAction(lexerMin,rule.action)}newrules.push(newrule)}}}if(lexerMin.languageId=languageId,lexerMin.includeLF=lexer.includeLF,lexerMin.ignoreCase=lexer.ignoreCase,lexerMin.unicode=lexer.unicode,lexerMin.noThrow=lexer.noThrow,lexerMin.usesEmbedded=lexer.usesEmbedded,lexerMin.stateNames=json.tokenizer,lexerMin.defaultToken=lexer.defaultToken,!json.tokenizer||"object"!=typeof json.tokenizer)throw monarchCommon.createError(lexer,"a language definition must define the 'tokenizer' attribute as an object");lexer.tokenizer=[];for(const key in json.tokenizer)if(json.tokenizer.hasOwnProperty(key)){lexer.start||(lexer.start=key);const rules=json.tokenizer[key];lexer.tokenizer[key]=new Array,addRules("tokenizer."+key,lexer.tokenizer[key],rules)}if(lexer.usesEmbedded=lexerMin.usesEmbedded,json.brackets){if(!Array.isArray(json.brackets))throw monarchCommon.createError(lexer,"the 'brackets' attribute must be defined as an array")}else json.brackets=[{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.square"},{open:"(",close:")",token:"delimiter.parenthesis"},{open:"<",close:">",token:"delimiter.angle"}];const brackets=[];for(const el of json.brackets){let desc=el;if(desc&&Array.isArray(desc)&&3===desc.length&&(desc={token:desc[2],open:desc[0],close:desc[1]}),desc.open===desc.close)throw monarchCommon.createError(lexer,"open and close brackets in a 'brackets' attribute must be different: "+desc.open+"\n hint: use the 'bracket' attribute if matching on equal brackets is required.");if("string"!=typeof desc.open||"string"!=typeof desc.token||"string"!=typeof desc.close)throw monarchCommon.createError(lexer,"every element in the 'brackets' array must be a '{open,close,token}' object or array");brackets.push({token:desc.token+lexer.tokenPostfix,open:monarchCommon.fixCase(lexer,desc.open),close:monarchCommon.fixCase(lexer,desc.close)})}return lexer.brackets=brackets,lexer.noThrow=!0,lexer}