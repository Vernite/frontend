import{MinimapCharRenderer}from"./minimapCharRenderer.js";import{allCharCodes}from"./minimapCharSheet.js";import{prebakedMiniMaps}from"./minimapPreBaked.js";import{toUint8}from"../../../../base/common/uint.js";export class MinimapCharRendererFactory{static create(scale,fontFamily){if(this.lastCreated&&scale===this.lastCreated.scale&&fontFamily===this.lastFontFamily)return this.lastCreated;let factory;return factory=prebakedMiniMaps[scale]?new MinimapCharRenderer(prebakedMiniMaps[scale](),scale):MinimapCharRendererFactory.createFromSampleData(MinimapCharRendererFactory.createSampleData(fontFamily).data,scale),this.lastFontFamily=fontFamily,this.lastCreated=factory,factory}static createSampleData(fontFamily){const canvas=document.createElement("canvas"),ctx=canvas.getContext("2d");canvas.style.height="16px",canvas.height=16,canvas.width=960,canvas.style.width="960px",ctx.fillStyle="#ffffff",ctx.font=`bold 16px ${fontFamily}`,ctx.textBaseline="middle";let x=0;for(const code of allCharCodes)ctx.fillText(String.fromCharCode(code),x,8),x+=10;return ctx.getImageData(0,0,960,16)}static createFromSampleData(source,scale){if(61440!==source.length)throw new Error("Unexpected source in MinimapCharRenderer");const charData=MinimapCharRendererFactory._downsample(source,scale);return new MinimapCharRenderer(charData,scale)}static _downsampleChar(source,sourceOffset,dest,destOffset,scale){const width=1*scale,height=2*scale;let targetIndex=destOffset,brightest=0;for(let y=0;y<height;y++){const sourceY1=y/height*16,sourceY2=(y+1)/height*16;for(let x=0;x<width;x++){const sourceX1=x/width*10,sourceX2=(x+1)/width*10;let value=0,samples=0;for(let sy=sourceY1;sy<sourceY2;sy++){const sourceRow=sourceOffset+3840*Math.floor(sy),yBalance=1-(sy-Math.floor(sy));for(let sx=sourceX1;sx<sourceX2;sx++){const xBalance=1-(sx-Math.floor(sx)),sourceIndex=sourceRow+4*Math.floor(sx),weight=xBalance*yBalance;samples+=weight,value+=source[sourceIndex]*source[sourceIndex+3]/255*weight}}const final=value/samples;brightest=Math.max(brightest,final),dest[targetIndex++]=toUint8(final)}}return brightest}static _downsample(data,scale){const pixelsPerCharacter=2*scale*1*scale,resultLen=96*pixelsPerCharacter,result=new Uint8ClampedArray(resultLen);let resultOffset=0,sourceOffset=0,brightest=0;for(let charIndex=0;charIndex<96;charIndex++)brightest=Math.max(brightest,this._downsampleChar(data,sourceOffset,result,resultOffset,scale)),resultOffset+=pixelsPerCharacter,sourceOffset+=40;if(brightest>0){const adjust=255/brightest;for(let i=0;i<resultLen;i++)result[i]*=adjust}return result}}