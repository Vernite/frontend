import{VSBuffer}from"../../../base/common/buffer.js";import*as platform from"../../../base/common/platform.js";function reverseEndianness(arr){for(let i=0,len=arr.length;i<len;i+=4){const b0=arr[i+0],b1=arr[i+1],b2=arr[i+2],b3=arr[i+3];arr[i+0]=b3,arr[i+1]=b2,arr[i+2]=b1,arr[i+3]=b0}}function toLittleEndianBuffer(arr){const uint8Arr=new Uint8Array(arr.buffer,arr.byteOffset,4*arr.length);return platform.isLittleEndian()||reverseEndianness(uint8Arr),VSBuffer.wrap(uint8Arr)}export function encodeSemanticTokensDto(semanticTokens){const dest=new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));let offset=0;if(dest[offset++]=semanticTokens.id,"full"===semanticTokens.type)dest[offset++]=1,dest[offset++]=semanticTokens.data.length,dest.set(semanticTokens.data,offset),offset+=semanticTokens.data.length;else{dest[offset++]=2,dest[offset++]=semanticTokens.deltas.length;for(const delta of semanticTokens.deltas)dest[offset++]=delta.start,dest[offset++]=delta.deleteCount,delta.data?(dest[offset++]=delta.data.length,dest.set(delta.data,offset),offset+=delta.data.length):dest[offset++]=0}return toLittleEndianBuffer(dest)}function encodeSemanticTokensDtoSize(semanticTokens){let result=0;if(result+=2,"full"===semanticTokens.type)result+=1+semanticTokens.data.length;else{result+=1,result+=3*semanticTokens.deltas.length;for(const delta of semanticTokens.deltas)delta.data&&(result+=delta.data.length)}return result}