var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):function adopt(value){return value instanceof P?value:new P((function(resolve){resolve(value)}))}(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))},__asyncValues=this&&this.__asyncValues||function(o){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i,m=o[Symbol.asyncIterator];return m?m.call(o):(o="function"==typeof __values?__values(o):o[Symbol.iterator](),i={},verb("next"),verb("throw"),verb("return"),i[Symbol.asyncIterator]=function(){return this},i);function verb(n){i[n]=o[n]&&function(v){return new Promise((function(resolve,reject){(function settle(resolve,reject,d,v){Promise.resolve(v).then((function(v){resolve({value:v,done:d})}),reject)})(resolve,reject,(v=o[n](v)).done,v.value)}))}}};import{CancellationTokenSource}from"./cancellation.js";import{CancellationError}from"./errors.js";import{Emitter,Event}from"./event.js";import{toDisposable}from"./lifecycle.js";import{setTimeout0}from"./platform.js";export function isThenable(obj){return!!obj&&"function"==typeof obj.then}export function createCancelablePromise(callback){const source=new CancellationTokenSource,thenable=callback(source.token),promise=new Promise(((resolve,reject)=>{const subscription=source.token.onCancellationRequested((()=>{subscription.dispose(),source.dispose(),reject(new CancellationError)}));Promise.resolve(thenable).then((value=>{subscription.dispose(),source.dispose(),resolve(value)}),(err=>{subscription.dispose(),source.dispose(),reject(err)}))}));return new class{cancel(){source.cancel()}then(resolve,reject){return promise.then(resolve,reject)}catch(reject){return this.then(void 0,reject)}finally(onfinally){return promise.finally(onfinally)}}}export function raceCancellation(promise,token,defaultValue){return new Promise(((resolve,reject)=>{const ref=token.onCancellationRequested((()=>{ref.dispose(),resolve(defaultValue)}));promise.then(resolve,reject).finally((()=>ref.dispose()))}))}export class Throttler{constructor(){this.activePromise=null,this.queuedPromise=null,this.queuedPromiseFactory=null}queue(promiseFactory){if(this.activePromise){if(this.queuedPromiseFactory=promiseFactory,!this.queuedPromise){const onComplete=()=>{this.queuedPromise=null;const result=this.queue(this.queuedPromiseFactory);return this.queuedPromiseFactory=null,result};this.queuedPromise=new Promise((resolve=>{this.activePromise.then(onComplete,onComplete).then(resolve)}))}return new Promise(((resolve,reject)=>{this.queuedPromise.then(resolve,reject)}))}return this.activePromise=promiseFactory(),new Promise(((resolve,reject)=>{this.activePromise.then((result=>{this.activePromise=null,resolve(result)}),(err=>{this.activePromise=null,reject(err)}))}))}}const timeoutDeferred=(timeout,fn)=>{let scheduled=!0;const handle=setTimeout((()=>{scheduled=!1,fn()}),timeout);return{isTriggered:()=>scheduled,dispose:()=>{clearTimeout(handle),scheduled=!1}}},microtaskDeferred=fn=>{let scheduled=!0;return queueMicrotask((()=>{scheduled&&(scheduled=!1,fn())})),{isTriggered:()=>scheduled,dispose:()=>{scheduled=!1}}};export const MicrotaskDelay=Symbol("MicrotaskDelay");export class Delayer{constructor(defaultDelay){this.defaultDelay=defaultDelay,this.deferred=null,this.completionPromise=null,this.doResolve=null,this.doReject=null,this.task=null}trigger(task,delay=this.defaultDelay){this.task=task,this.cancelTimeout(),this.completionPromise||(this.completionPromise=new Promise(((resolve,reject)=>{this.doResolve=resolve,this.doReject=reject})).then((()=>{if(this.completionPromise=null,this.doResolve=null,this.task){const task=this.task;return this.task=null,task()}})));const fn=()=>{var _a;this.deferred=null,null===(_a=this.doResolve)||void 0===_a||_a.call(this,null)};return this.deferred=delay===MicrotaskDelay?microtaskDeferred(fn):timeoutDeferred(delay,fn),this.completionPromise}isTriggered(){var _a;return!!(null===(_a=this.deferred)||void 0===_a?void 0:_a.isTriggered())}cancel(){var _a;this.cancelTimeout(),this.completionPromise&&(null===(_a=this.doReject)||void 0===_a||_a.call(this,new CancellationError),this.completionPromise=null)}cancelTimeout(){var _a;null===(_a=this.deferred)||void 0===_a||_a.dispose(),this.deferred=null}dispose(){this.cancel()}}export class ThrottledDelayer{constructor(defaultDelay){this.delayer=new Delayer(defaultDelay),this.throttler=new Throttler}trigger(promiseFactory,delay){return this.delayer.trigger((()=>this.throttler.queue(promiseFactory)),delay)}dispose(){this.delayer.dispose()}}export function timeout(millis,token){return token?new Promise(((resolve,reject)=>{const handle=setTimeout((()=>{disposable.dispose(),resolve()}),millis),disposable=token.onCancellationRequested((()=>{clearTimeout(handle),disposable.dispose(),reject(new CancellationError)}))})):createCancelablePromise((token=>timeout(millis,token)))}export function disposableTimeout(handler,timeout=0){const timer=setTimeout(handler,timeout);return toDisposable((()=>clearTimeout(timer)))}export function first(promiseFactories,shouldStop=(t=>!!t),defaultValue=null){let index=0;const len=promiseFactories.length,loop=()=>{if(index>=len)return Promise.resolve(defaultValue);const factory=promiseFactories[index++];return Promise.resolve(factory()).then((result=>shouldStop(result)?Promise.resolve(result):loop()))};return loop()}export class TimeoutTimer{constructor(runner,timeout){this._token=-1,"function"==typeof runner&&"number"==typeof timeout&&this.setIfNotSet(runner,timeout)}dispose(){this.cancel()}cancel(){-1!==this._token&&(clearTimeout(this._token),this._token=-1)}cancelAndSet(runner,timeout){this.cancel(),this._token=setTimeout((()=>{this._token=-1,runner()}),timeout)}setIfNotSet(runner,timeout){-1===this._token&&(this._token=setTimeout((()=>{this._token=-1,runner()}),timeout))}}export class IntervalTimer{constructor(){this._token=-1}dispose(){this.cancel()}cancel(){-1!==this._token&&(clearInterval(this._token),this._token=-1)}cancelAndSet(runner,interval){this.cancel(),this._token=setInterval((()=>{runner()}),interval)}}export class RunOnceScheduler{constructor(runner,delay){this.timeoutToken=-1,this.runner=runner,this.timeout=delay,this.timeoutHandler=this.onTimeout.bind(this)}dispose(){this.cancel(),this.runner=null}cancel(){this.isScheduled()&&(clearTimeout(this.timeoutToken),this.timeoutToken=-1)}schedule(delay=this.timeout){this.cancel(),this.timeoutToken=setTimeout(this.timeoutHandler,delay)}get delay(){return this.timeout}set delay(value){this.timeout=value}isScheduled(){return-1!==this.timeoutToken}onTimeout(){this.timeoutToken=-1,this.runner&&this.doRun()}doRun(){var _a;null===(_a=this.runner)||void 0===_a||_a.call(this)}}export let runWhenIdle;runWhenIdle="function"!=typeof requestIdleCallback||"function"!=typeof cancelIdleCallback?runner=>{setTimeout0((()=>{if(disposed)return;const end=Date.now()+15;runner(Object.freeze({didTimeout:!0,timeRemaining:()=>Math.max(0,end-Date.now())}))}));let disposed=!1;return{dispose(){disposed||(disposed=!0)}}}:(runner,timeout)=>{const handle=requestIdleCallback(runner,"number"==typeof timeout?{timeout}:void 0);let disposed=!1;return{dispose(){disposed||(disposed=!0,cancelIdleCallback(handle))}}};export class IdleValue{constructor(executor){this._didRun=!1,this._executor=()=>{try{this._value=executor()}catch(err){this._error=err}finally{this._didRun=!0}},this._handle=runWhenIdle((()=>this._executor()))}dispose(){this._handle.dispose()}get value(){if(this._didRun||(this._handle.dispose(),this._executor()),this._error)throw this._error;return this._value}get isInitialized(){return this._didRun}}export class DeferredPromise{constructor(){this.rejected=!1,this.resolved=!1,this.p=new Promise(((c,e)=>{this.completeCallback=c,this.errorCallback=e}))}get isRejected(){return this.rejected}get isSettled(){return this.rejected||this.resolved}complete(value){return new Promise((resolve=>{this.completeCallback(value),this.resolved=!0,resolve()}))}cancel(){new Promise((resolve=>{this.errorCallback(new CancellationError),this.rejected=!0,resolve()}))}}export var Promises;!function(Promises){Promises.settled=function settled(promises){return __awaiter(this,void 0,void 0,(function*(){let firstError;const result=yield Promise.all(promises.map((promise=>promise.then((value=>value),(error=>{firstError||(firstError=error)})))));if(void 0!==firstError)throw firstError;return result}))},Promises.withAsyncBody=function withAsyncBody(bodyFn){return new Promise(((resolve,reject)=>__awaiter(this,void 0,void 0,(function*(){try{yield bodyFn(resolve,reject)}catch(error){reject(error)}}))))}}(Promises||(Promises={}));export class AsyncIterableObject{constructor(executor){this._state=0,this._results=[],this._error=null,this._onStateChanged=new Emitter,queueMicrotask((()=>__awaiter(this,void 0,void 0,(function*(){const writer={emitOne:item=>this.emitOne(item),emitMany:items=>this.emitMany(items),reject:error=>this.reject(error)};try{yield Promise.resolve(executor(writer)),this.resolve()}catch(err){this.reject(err)}finally{writer.emitOne=void 0,writer.emitMany=void 0,writer.reject=void 0}}))))}static fromArray(items){return new AsyncIterableObject((writer=>{writer.emitMany(items)}))}static fromPromise(promise){return new AsyncIterableObject((emitter=>__awaiter(this,void 0,void 0,(function*(){emitter.emitMany(yield promise)}))))}static fromPromises(promises){return new AsyncIterableObject((emitter=>__awaiter(this,void 0,void 0,(function*(){yield Promise.all(promises.map((p=>__awaiter(this,void 0,void 0,(function*(){return emitter.emitOne(yield p)})))))}))))}static merge(iterables){return new AsyncIterableObject((emitter=>__awaiter(this,void 0,void 0,(function*(){yield Promise.all(iterables.map((iterable=>{var iterable_1,iterable_1_1;return __awaiter(this,void 0,void 0,(function*(){var e_1,_a;try{for(iterable_1=__asyncValues(iterable);!(iterable_1_1=yield iterable_1.next()).done;){const item=iterable_1_1.value;emitter.emitOne(item)}}catch(e_1_1){e_1={error:e_1_1}}finally{try{iterable_1_1&&!iterable_1_1.done&&(_a=iterable_1.return)&&(yield _a.call(iterable_1))}finally{if(e_1)throw e_1.error}}}))})))}))))}[Symbol.asyncIterator](){let i=0;return{next:()=>__awaiter(this,void 0,void 0,(function*(){for(;;){if(2===this._state)throw this._error;if(i<this._results.length)return{done:!1,value:this._results[i++]};if(1===this._state)return{done:!0,value:void 0};yield Event.toPromise(this._onStateChanged.event)}}))}}static map(iterable,mapFn){return new AsyncIterableObject((emitter=>__awaiter(this,void 0,void 0,(function*(){var e_2,_a;try{for(var iterable_2_1,iterable_2=__asyncValues(iterable);!(iterable_2_1=yield iterable_2.next()).done;){const item=iterable_2_1.value;emitter.emitOne(mapFn(item))}}catch(e_2_1){e_2={error:e_2_1}}finally{try{iterable_2_1&&!iterable_2_1.done&&(_a=iterable_2.return)&&(yield _a.call(iterable_2))}finally{if(e_2)throw e_2.error}}}))))}map(mapFn){return AsyncIterableObject.map(this,mapFn)}static filter(iterable,filterFn){return new AsyncIterableObject((emitter=>__awaiter(this,void 0,void 0,(function*(){var e_3,_a;try{for(var iterable_3_1,iterable_3=__asyncValues(iterable);!(iterable_3_1=yield iterable_3.next()).done;){const item=iterable_3_1.value;filterFn(item)&&emitter.emitOne(item)}}catch(e_3_1){e_3={error:e_3_1}}finally{try{iterable_3_1&&!iterable_3_1.done&&(_a=iterable_3.return)&&(yield _a.call(iterable_3))}finally{if(e_3)throw e_3.error}}}))))}filter(filterFn){return AsyncIterableObject.filter(this,filterFn)}static coalesce(iterable){return AsyncIterableObject.filter(iterable,(item=>!!item))}coalesce(){return AsyncIterableObject.coalesce(this)}static toPromise(iterable){var iterable_4,iterable_4_1,e_4,_a;return __awaiter(this,void 0,void 0,(function*(){const result=[];try{for(iterable_4=__asyncValues(iterable);!(iterable_4_1=yield iterable_4.next()).done;){const item=iterable_4_1.value;result.push(item)}}catch(e_4_1){e_4={error:e_4_1}}finally{try{iterable_4_1&&!iterable_4_1.done&&(_a=iterable_4.return)&&(yield _a.call(iterable_4))}finally{if(e_4)throw e_4.error}}return result}))}toPromise(){return AsyncIterableObject.toPromise(this)}emitOne(value){0===this._state&&(this._results.push(value),this._onStateChanged.fire())}emitMany(values){0===this._state&&(this._results=this._results.concat(values),this._onStateChanged.fire())}resolve(){0===this._state&&(this._state=1,this._onStateChanged.fire())}reject(error){0===this._state&&(this._state=2,this._error=error,this._onStateChanged.fire())}}AsyncIterableObject.EMPTY=AsyncIterableObject.fromArray([]);export class CancelableAsyncIterableObject extends AsyncIterableObject{constructor(_source,executor){super(executor),this._source=_source}cancel(){this._source.cancel()}}export function createCancelableAsyncIterable(callback){const source=new CancellationTokenSource,innerIterable=callback(source.token);return new CancelableAsyncIterableObject(source,(emitter=>__awaiter(this,void 0,void 0,(function*(){var e_5,_a;const subscription=source.token.onCancellationRequested((()=>{subscription.dispose(),source.dispose(),emitter.reject(new CancellationError)}));try{try{for(var innerIterable_1_1,innerIterable_1=__asyncValues(innerIterable);!(innerIterable_1_1=yield innerIterable_1.next()).done;){const item=innerIterable_1_1.value;if(source.token.isCancellationRequested)return;emitter.emitOne(item)}}catch(e_5_1){e_5={error:e_5_1}}finally{try{innerIterable_1_1&&!innerIterable_1_1.done&&(_a=innerIterable_1.return)&&(yield _a.call(innerIterable_1))}finally{if(e_5)throw e_5.error}}subscription.dispose(),source.dispose()}catch(err){subscription.dispose(),source.dispose(),emitter.reject(err)}}))))}