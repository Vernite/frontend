import{IntervalTimer,TimeoutTimer}from"../../../base/common/async.js";import{Emitter,Event}from"../../../base/common/event.js";import{Disposable}from"../../../base/common/lifecycle.js";import*as nls from"../../../nls.js";const HIGH_FREQ_COMMANDS=/^(cursor|delete)/;export class AbstractKeybindingService extends Disposable{constructor(_contextKeyService,_commandService,_telemetryService,_notificationService,_logService){super(),this._contextKeyService=_contextKeyService,this._commandService=_commandService,this._telemetryService=_telemetryService,this._notificationService=_notificationService,this._logService=_logService,this._onDidUpdateKeybindings=this._register(new Emitter),this._currentChord=null,this._currentChordChecker=new IntervalTimer,this._currentChordStatusMessage=null,this._ignoreSingleModifiers=KeybindingModifierSet.EMPTY,this._currentSingleModifier=null,this._currentSingleModifierClearTimeout=new TimeoutTimer,this._logging=!1}get onDidUpdateKeybindings(){return this._onDidUpdateKeybindings?this._onDidUpdateKeybindings.event:Event.None}dispose(){super.dispose()}_log(str){this._logging&&this._logService.info(`[KeybindingService]: ${str}`)}getKeybindings(){return this._getResolver().getKeybindings()}lookupKeybinding(commandId,context){const result=this._getResolver().lookupPrimaryKeybinding(commandId,context||this._contextKeyService);if(result)return result.resolvedKeybinding}dispatchEvent(e,target){return this._dispatch(e,target)}softDispatch(e,target){this._log("/ Soft dispatching keyboard event");const keybinding=this.resolveKeyboardEvent(e);if(keybinding.isChord())return console.warn("Unexpected keyboard event mapped to a chord"),null;const[firstPart]=keybinding.getDispatchParts();if(null===firstPart)return this._log("\\ Keyboard event cannot be dispatched"),null;const contextValue=this._contextKeyService.getContext(target),currentChord=this._currentChord?this._currentChord.keypress:null;return this._getResolver().resolve(contextValue,currentChord,firstPart)}_enterChordMode(firstPart,keypressLabel){this._currentChord={keypress:firstPart,label:keypressLabel},this._currentChordStatusMessage=this._notificationService.status(nls.localize("first.chord","({0}) was pressed. Waiting for second key of chord...",keypressLabel));const chordEnterTime=Date.now();this._currentChordChecker.cancelAndSet((()=>{this._documentHasFocus()?Date.now()-chordEnterTime>5e3&&this._leaveChordMode():this._leaveChordMode()}),500)}_leaveChordMode(){this._currentChordStatusMessage&&(this._currentChordStatusMessage.dispose(),this._currentChordStatusMessage=null),this._currentChordChecker.cancel(),this._currentChord=null}_dispatch(e,target){return this._doDispatch(this.resolveKeyboardEvent(e),target,!1)}_singleModifierDispatch(e,target){const keybinding=this.resolveKeyboardEvent(e),[singleModifier]=keybinding.getSingleModifierDispatchParts();if(singleModifier)return this._ignoreSingleModifiers.has(singleModifier)?(this._log(`+ Ignoring single modifier ${singleModifier} due to it being pressed together with other keys.`),this._ignoreSingleModifiers=KeybindingModifierSet.EMPTY,this._currentSingleModifierClearTimeout.cancel(),this._currentSingleModifier=null,!1):(this._ignoreSingleModifiers=KeybindingModifierSet.EMPTY,null===this._currentSingleModifier?(this._log(`+ Storing single modifier for possible chord ${singleModifier}.`),this._currentSingleModifier=singleModifier,this._currentSingleModifierClearTimeout.cancelAndSet((()=>{this._log("+ Clearing single modifier due to 300ms elapsed."),this._currentSingleModifier=null}),300),!1):singleModifier===this._currentSingleModifier?(this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`),this._currentSingleModifierClearTimeout.cancel(),this._currentSingleModifier=null,this._doDispatch(keybinding,target,!0)):(this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${singleModifier}`),this._currentSingleModifierClearTimeout.cancel(),this._currentSingleModifier=null,!1));const[firstPart]=keybinding.getParts();return this._ignoreSingleModifiers=new KeybindingModifierSet(firstPart),null!==this._currentSingleModifier&&this._log("+ Clearing single modifier due to other key up."),this._currentSingleModifierClearTimeout.cancel(),this._currentSingleModifier=null,!1}_doDispatch(keybinding,target,isSingleModiferChord=!1){let shouldPreventDefault=!1;if(keybinding.isChord())return console.warn("Unexpected keyboard event mapped to a chord"),!1;let firstPart=null,currentChord=null;if(isSingleModiferChord){const[dispatchKeyname]=keybinding.getSingleModifierDispatchParts();firstPart=dispatchKeyname,currentChord=dispatchKeyname}else[firstPart]=keybinding.getDispatchParts(),currentChord=this._currentChord?this._currentChord.keypress:null;if(null===firstPart)return this._log("\\ Keyboard event cannot be dispatched in keydown phase."),shouldPreventDefault;const contextValue=this._contextKeyService.getContext(target),keypressLabel=keybinding.getLabel(),resolveResult=this._getResolver().resolve(contextValue,currentChord,firstPart);return this._logService.trace("KeybindingService#dispatch",keypressLabel,null==resolveResult?void 0:resolveResult.commandId),resolveResult&&resolveResult.enterChord?(shouldPreventDefault=!0,this._enterChordMode(firstPart,keypressLabel),this._log("+ Entering chord mode..."),shouldPreventDefault):(this._currentChord&&(resolveResult&&resolveResult.commandId||(this._log(`+ Leaving chord mode: Nothing bound to "${this._currentChord.label} ${keypressLabel}".`),this._notificationService.status(nls.localize("missing.chord","The key combination ({0}, {1}) is not a command.",this._currentChord.label,keypressLabel),{hideAfter:1e4}),shouldPreventDefault=!0)),this._leaveChordMode(),resolveResult&&resolveResult.commandId&&(resolveResult.bubble||(shouldPreventDefault=!0),this._log(`+ Invoking command ${resolveResult.commandId}.`),void 0===resolveResult.commandArgs?this._commandService.executeCommand(resolveResult.commandId).then(void 0,(err=>this._notificationService.warn(err))):this._commandService.executeCommand(resolveResult.commandId,resolveResult.commandArgs).then(void 0,(err=>this._notificationService.warn(err))),HIGH_FREQ_COMMANDS.test(resolveResult.commandId)||this._telemetryService.publicLog2("workbenchActionExecuted",{id:resolveResult.commandId,from:"keybinding"})),shouldPreventDefault)}mightProducePrintableCharacter(event){return!event.ctrlKey&&!event.metaKey&&(event.keyCode>=31&&event.keyCode<=56||event.keyCode>=21&&event.keyCode<=30)}}class KeybindingModifierSet{constructor(source){this._ctrlKey=!!source&&source.ctrlKey,this._shiftKey=!!source&&source.shiftKey,this._altKey=!!source&&source.altKey,this._metaKey=!!source&&source.metaKey}has(modifier){switch(modifier){case"ctrl":return this._ctrlKey;case"shift":return this._shiftKey;case"alt":return this._altKey;case"meta":return this._metaKey}}}KeybindingModifierSet.EMPTY=new KeybindingModifierSet(null);