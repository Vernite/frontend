import{Position}from"../core/position.js";import{Range}from"../core/range.js";import{countEOL}from"../core/eolCounter.js";export class SparseMultilineTokens{constructor(startLineNumber,tokens){this._startLineNumber=startLineNumber,this._tokens=tokens,this._endLineNumber=this._startLineNumber+this._tokens.getMaxDeltaLine()}static create(startLineNumber,tokens){return new SparseMultilineTokens(startLineNumber,new SparseMultilineTokensStorage(tokens))}get startLineNumber(){return this._startLineNumber}get endLineNumber(){return this._endLineNumber}toString(){return this._tokens.toString(this._startLineNumber)}_updateEndLineNumber(){this._endLineNumber=this._startLineNumber+this._tokens.getMaxDeltaLine()}isEmpty(){return this._tokens.isEmpty()}getLineTokens(lineNumber){return this._startLineNumber<=lineNumber&&lineNumber<=this._endLineNumber?this._tokens.getLineTokens(lineNumber-this._startLineNumber):null}getRange(){const deltaRange=this._tokens.getRange();return deltaRange?new Range(this._startLineNumber+deltaRange.startLineNumber,deltaRange.startColumn,this._startLineNumber+deltaRange.endLineNumber,deltaRange.endColumn):deltaRange}removeTokens(range){const startLineIndex=range.startLineNumber-this._startLineNumber,endLineIndex=range.endLineNumber-this._startLineNumber;this._startLineNumber+=this._tokens.removeTokens(startLineIndex,range.startColumn-1,endLineIndex,range.endColumn-1),this._updateEndLineNumber()}split(range){const startLineIndex=range.startLineNumber-this._startLineNumber,endLineIndex=range.endLineNumber-this._startLineNumber,[a,b,bDeltaLine]=this._tokens.split(startLineIndex,range.startColumn-1,endLineIndex,range.endColumn-1);return[new SparseMultilineTokens(this._startLineNumber,a),new SparseMultilineTokens(this._startLineNumber+bDeltaLine,b)]}applyEdit(range,text){const[eolCount,firstLineLength,lastLineLength]=countEOL(text);this.acceptEdit(range,eolCount,firstLineLength,lastLineLength,text.length>0?text.charCodeAt(0):0)}acceptEdit(range,eolCount,firstLineLength,lastLineLength,firstCharCode){this._acceptDeleteRange(range),this._acceptInsertText(new Position(range.startLineNumber,range.startColumn),eolCount,firstLineLength,lastLineLength,firstCharCode),this._updateEndLineNumber()}_acceptDeleteRange(range){if(range.startLineNumber===range.endLineNumber&&range.startColumn===range.endColumn)return;const firstLineIndex=range.startLineNumber-this._startLineNumber,lastLineIndex=range.endLineNumber-this._startLineNumber;if(lastLineIndex<0){const deletedLinesCount=lastLineIndex-firstLineIndex;return void(this._startLineNumber-=deletedLinesCount)}const tokenMaxDeltaLine=this._tokens.getMaxDeltaLine();if(!(firstLineIndex>=tokenMaxDeltaLine+1)){if(firstLineIndex<0&&lastLineIndex>=tokenMaxDeltaLine+1)return this._startLineNumber=0,void this._tokens.clear();if(firstLineIndex<0){const deletedBefore=-firstLineIndex;this._startLineNumber-=deletedBefore,this._tokens.acceptDeleteRange(range.startColumn-1,0,0,lastLineIndex,range.endColumn-1)}else this._tokens.acceptDeleteRange(0,firstLineIndex,range.startColumn-1,lastLineIndex,range.endColumn-1)}}_acceptInsertText(position,eolCount,firstLineLength,lastLineLength,firstCharCode){if(0===eolCount&&0===firstLineLength)return;const lineIndex=position.lineNumber-this._startLineNumber;if(lineIndex<0)return void(this._startLineNumber+=eolCount);lineIndex>=this._tokens.getMaxDeltaLine()+1||this._tokens.acceptInsertText(lineIndex,position.column-1,eolCount,firstLineLength,lastLineLength,firstCharCode)}}class SparseMultilineTokensStorage{constructor(tokens){this._tokens=tokens,this._tokenCount=tokens.length/4}toString(startLineNumber){const pieces=[];for(let i=0;i<this._tokenCount;i++)pieces.push(`(${this._getDeltaLine(i)+startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);return`[${pieces.join(",")}]`}getMaxDeltaLine(){const tokenCount=this._getTokenCount();return 0===tokenCount?-1:this._getDeltaLine(tokenCount-1)}getRange(){const tokenCount=this._getTokenCount();if(0===tokenCount)return null;const startChar=this._getStartCharacter(0),maxDeltaLine=this._getDeltaLine(tokenCount-1),endChar=this._getEndCharacter(tokenCount-1);return new Range(0,startChar+1,maxDeltaLine,endChar+1)}_getTokenCount(){return this._tokenCount}_getDeltaLine(tokenIndex){return this._tokens[4*tokenIndex]}_getStartCharacter(tokenIndex){return this._tokens[4*tokenIndex+1]}_getEndCharacter(tokenIndex){return this._tokens[4*tokenIndex+2]}isEmpty(){return 0===this._getTokenCount()}getLineTokens(deltaLine){let low=0,high=this._getTokenCount()-1;for(;low<high;){const mid=low+Math.floor((high-low)/2),midDeltaLine=this._getDeltaLine(mid);if(midDeltaLine<deltaLine)low=mid+1;else{if(!(midDeltaLine>deltaLine)){let min=mid;for(;min>low&&this._getDeltaLine(min-1)===deltaLine;)min--;let max=mid;for(;max<high&&this._getDeltaLine(max+1)===deltaLine;)max++;return new SparseLineTokens(this._tokens.subarray(4*min,4*max+4))}high=mid-1}}return this._getDeltaLine(low)===deltaLine?new SparseLineTokens(this._tokens.subarray(4*low,4*low+4)):null}clear(){this._tokenCount=0}removeTokens(startDeltaLine,startChar,endDeltaLine,endChar){const tokens=this._tokens,tokenCount=this._tokenCount;let newTokenCount=0,hasDeletedTokens=!1,firstDeltaLine=0;for(let i=0;i<tokenCount;i++){const srcOffset=4*i,tokenDeltaLine=tokens[srcOffset],tokenStartCharacter=tokens[srcOffset+1],tokenEndCharacter=tokens[srcOffset+2],tokenMetadata=tokens[srcOffset+3];if((tokenDeltaLine>startDeltaLine||tokenDeltaLine===startDeltaLine&&tokenEndCharacter>=startChar)&&(tokenDeltaLine<endDeltaLine||tokenDeltaLine===endDeltaLine&&tokenStartCharacter<=endChar))hasDeletedTokens=!0;else{if(0===newTokenCount&&(firstDeltaLine=tokenDeltaLine),hasDeletedTokens){const destOffset=4*newTokenCount;tokens[destOffset]=tokenDeltaLine-firstDeltaLine,tokens[destOffset+1]=tokenStartCharacter,tokens[destOffset+2]=tokenEndCharacter,tokens[destOffset+3]=tokenMetadata}newTokenCount++}}return this._tokenCount=newTokenCount,firstDeltaLine}split(startDeltaLine,startChar,endDeltaLine,endChar){const tokens=this._tokens,tokenCount=this._tokenCount,aTokens=[],bTokens=[];let destTokens=aTokens,destOffset=0,destFirstDeltaLine=0;for(let i=0;i<tokenCount;i++){const srcOffset=4*i,tokenDeltaLine=tokens[srcOffset],tokenStartCharacter=tokens[srcOffset+1],tokenEndCharacter=tokens[srcOffset+2],tokenMetadata=tokens[srcOffset+3];if(tokenDeltaLine>startDeltaLine||tokenDeltaLine===startDeltaLine&&tokenEndCharacter>=startChar){if(tokenDeltaLine<endDeltaLine||tokenDeltaLine===endDeltaLine&&tokenStartCharacter<=endChar)continue;destTokens!==bTokens&&(destTokens=bTokens,destOffset=0,destFirstDeltaLine=tokenDeltaLine)}destTokens[destOffset++]=tokenDeltaLine-destFirstDeltaLine,destTokens[destOffset++]=tokenStartCharacter,destTokens[destOffset++]=tokenEndCharacter,destTokens[destOffset++]=tokenMetadata}return[new SparseMultilineTokensStorage(new Uint32Array(aTokens)),new SparseMultilineTokensStorage(new Uint32Array(bTokens)),destFirstDeltaLine]}acceptDeleteRange(horizontalShiftForFirstLineTokens,startDeltaLine,startCharacter,endDeltaLine,endCharacter){const tokens=this._tokens,tokenCount=this._tokenCount,deletedLineCount=endDeltaLine-startDeltaLine;let newTokenCount=0,hasDeletedTokens=!1;for(let i=0;i<tokenCount;i++){const srcOffset=4*i;let tokenDeltaLine=tokens[srcOffset],tokenStartCharacter=tokens[srcOffset+1],tokenEndCharacter=tokens[srcOffset+2];const tokenMetadata=tokens[srcOffset+3];if(tokenDeltaLine<startDeltaLine||tokenDeltaLine===startDeltaLine&&tokenEndCharacter<=startCharacter){newTokenCount++;continue}if(tokenDeltaLine===startDeltaLine&&tokenStartCharacter<startCharacter)tokenDeltaLine===endDeltaLine&&tokenEndCharacter>endCharacter?tokenEndCharacter-=endCharacter-startCharacter:tokenEndCharacter=startCharacter;else if(tokenDeltaLine===startDeltaLine&&tokenStartCharacter===startCharacter){if(!(tokenDeltaLine===endDeltaLine&&tokenEndCharacter>endCharacter)){hasDeletedTokens=!0;continue}tokenEndCharacter-=endCharacter-startCharacter}else if(tokenDeltaLine<endDeltaLine||tokenDeltaLine===endDeltaLine&&tokenStartCharacter<endCharacter){if(!(tokenDeltaLine===endDeltaLine&&tokenEndCharacter>endCharacter)){hasDeletedTokens=!0;continue}tokenDeltaLine===startDeltaLine?(tokenStartCharacter=startCharacter,tokenEndCharacter=tokenStartCharacter+(tokenEndCharacter-endCharacter)):(tokenStartCharacter=0,tokenEndCharacter=tokenStartCharacter+(tokenEndCharacter-endCharacter))}else if(tokenDeltaLine>endDeltaLine){if(0===deletedLineCount&&!hasDeletedTokens){newTokenCount=tokenCount;break}tokenDeltaLine-=deletedLineCount}else{if(!(tokenDeltaLine===endDeltaLine&&tokenStartCharacter>=endCharacter))throw new Error("Not possible!");horizontalShiftForFirstLineTokens&&0===tokenDeltaLine&&(tokenStartCharacter+=horizontalShiftForFirstLineTokens,tokenEndCharacter+=horizontalShiftForFirstLineTokens),tokenDeltaLine-=deletedLineCount,tokenStartCharacter-=endCharacter-startCharacter,tokenEndCharacter-=endCharacter-startCharacter}const destOffset=4*newTokenCount;tokens[destOffset]=tokenDeltaLine,tokens[destOffset+1]=tokenStartCharacter,tokens[destOffset+2]=tokenEndCharacter,tokens[destOffset+3]=tokenMetadata,newTokenCount++}this._tokenCount=newTokenCount}acceptInsertText(deltaLine,character,eolCount,firstLineLength,lastLineLength,firstCharCode){const isInsertingPreciselyOneWordCharacter=0===eolCount&&1===firstLineLength&&(firstCharCode>=48&&firstCharCode<=57||firstCharCode>=65&&firstCharCode<=90||firstCharCode>=97&&firstCharCode<=122),tokens=this._tokens,tokenCount=this._tokenCount;for(let i=0;i<tokenCount;i++){const offset=4*i;let tokenDeltaLine=tokens[offset],tokenStartCharacter=tokens[offset+1],tokenEndCharacter=tokens[offset+2];if(!(tokenDeltaLine<deltaLine||tokenDeltaLine===deltaLine&&tokenEndCharacter<character)){if(tokenDeltaLine===deltaLine&&tokenEndCharacter===character){if(!isInsertingPreciselyOneWordCharacter)continue;tokenEndCharacter+=1}else if(tokenDeltaLine===deltaLine&&tokenStartCharacter<character&&character<tokenEndCharacter)0===eolCount?tokenEndCharacter+=firstLineLength:tokenEndCharacter=character;else{if(tokenDeltaLine===deltaLine&&tokenStartCharacter===character&&isInsertingPreciselyOneWordCharacter)continue;if(tokenDeltaLine===deltaLine)if(tokenDeltaLine+=eolCount,0===eolCount)tokenStartCharacter+=firstLineLength,tokenEndCharacter+=firstLineLength;else{const tokenLength=tokenEndCharacter-tokenStartCharacter;tokenStartCharacter=lastLineLength+(tokenStartCharacter-character),tokenEndCharacter=tokenStartCharacter+tokenLength}else tokenDeltaLine+=eolCount}tokens[offset]=tokenDeltaLine,tokens[offset+1]=tokenStartCharacter,tokens[offset+2]=tokenEndCharacter}}}}export class SparseLineTokens{constructor(tokens){this._tokens=tokens}getCount(){return this._tokens.length/4}getStartCharacter(tokenIndex){return this._tokens[4*tokenIndex+1]}getEndCharacter(tokenIndex){return this._tokens[4*tokenIndex+2]}getMetadata(tokenIndex){return this._tokens[4*tokenIndex+3]}}