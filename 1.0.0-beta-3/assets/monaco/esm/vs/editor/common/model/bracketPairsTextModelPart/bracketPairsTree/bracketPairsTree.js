import{Emitter}from"../../../../../base/common/event.js";import{Disposable}from"../../../../../base/common/lifecycle.js";import{Range}from"../../../core/range.js";import{BracketInfo,BracketPairWithMinIndentationInfo}from"../../../textModelBracketPairs.js";import{TextEditInfo}from"./beforeEditPositionMapper.js";import{LanguageAgnosticBracketTokens}from"./brackets.js";import{lengthAdd,lengthGreaterThanEqual,lengthLessThan,lengthLessThanEqual,lengthOfString,lengthsToRange,lengthZero,positionToLength,toLength}from"./length.js";import{parseDocument}from"./parser.js";import{DenseKeyProvider}from"./smallImmutableSet.js";import{FastTokenizer,TextBufferTokenizer}from"./tokenizer.js";export class BracketPairsTree extends Disposable{constructor(textModel,getLanguageConfiguration){if(super(),this.textModel=textModel,this.getLanguageConfiguration=getLanguageConfiguration,this.didChangeEmitter=new Emitter,this.denseKeyProvider=new DenseKeyProvider,this.brackets=new LanguageAgnosticBracketTokens(this.denseKeyProvider,this.getLanguageConfiguration),this.onDidChange=this.didChangeEmitter.event,0===textModel.tokenization.backgroundTokenizationState){const brackets=this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId()),tokenizer=new FastTokenizer(this.textModel.getValue(),brackets);this.initialAstWithoutTokens=parseDocument(tokenizer,[],void 0,!0),this.astWithTokens=this.initialAstWithoutTokens}else 2===textModel.tokenization.backgroundTokenizationState?(this.initialAstWithoutTokens=void 0,this.astWithTokens=this.parseDocumentFromTextBuffer([],void 0,!1)):1===textModel.tokenization.backgroundTokenizationState&&(this.initialAstWithoutTokens=this.parseDocumentFromTextBuffer([],void 0,!0),this.astWithTokens=this.initialAstWithoutTokens)}didLanguageChange(languageId){return this.brackets.didLanguageChange(languageId)}handleDidChangeBackgroundTokenizationState(){if(2===this.textModel.tokenization.backgroundTokenizationState){const wasUndefined=void 0===this.initialAstWithoutTokens;this.initialAstWithoutTokens=void 0,wasUndefined||this.didChangeEmitter.fire()}}handleDidChangeTokens({ranges}){const edits=ranges.map((r=>new TextEditInfo(toLength(r.fromLineNumber-1,0),toLength(r.toLineNumber,0),toLength(r.toLineNumber-r.fromLineNumber+1,0))));this.astWithTokens=this.parseDocumentFromTextBuffer(edits,this.astWithTokens,!1),this.initialAstWithoutTokens||this.didChangeEmitter.fire()}handleContentChanged(change){const edits=change.changes.map((c=>{const range=Range.lift(c.range);return new TextEditInfo(positionToLength(range.getStartPosition()),positionToLength(range.getEndPosition()),lengthOfString(c.text))})).reverse();this.astWithTokens=this.parseDocumentFromTextBuffer(edits,this.astWithTokens,!1),this.initialAstWithoutTokens&&(this.initialAstWithoutTokens=this.parseDocumentFromTextBuffer(edits,this.initialAstWithoutTokens,!1))}parseDocumentFromTextBuffer(edits,previousAst,immutable){const previousAstClone=previousAst,tokenizer=new TextBufferTokenizer(this.textModel,this.brackets);return parseDocument(tokenizer,edits,previousAstClone,immutable)}getBracketsInRange(range){const startOffset=toLength(range.startLineNumber-1,range.startColumn-1),endOffset=toLength(range.endLineNumber-1,range.endColumn-1),result=new Array,node=this.initialAstWithoutTokens||this.astWithTokens;return collectBrackets(node,lengthZero,node.length,startOffset,endOffset,result,0,new Map),result}getBracketPairsInRange(range,includeMinIndentation){const result=new Array,startLength=positionToLength(range.getStartPosition()),endLength=positionToLength(range.getEndPosition()),node=this.initialAstWithoutTokens||this.astWithTokens,context=new CollectBracketPairsContext(result,includeMinIndentation,this.textModel);return collectBracketPairs(node,lengthZero,node.length,startLength,endLength,context,0,new Map),result}getFirstBracketAfter(position){const node=this.initialAstWithoutTokens||this.astWithTokens;return getFirstBracketAfter(node,lengthZero,node.length,positionToLength(position))}getFirstBracketBefore(position){const node=this.initialAstWithoutTokens||this.astWithTokens;return getFirstBracketBefore(node,lengthZero,node.length,positionToLength(position))}}function getFirstBracketBefore(node,nodeOffsetStart,nodeOffsetEnd,position){if(4===node.kind||2===node.kind){const lengths=[];for(const child of node.children)nodeOffsetEnd=lengthAdd(nodeOffsetStart,child.length),lengths.push({nodeOffsetStart,nodeOffsetEnd}),nodeOffsetStart=nodeOffsetEnd;for(let i=lengths.length-1;i>=0;i--){const{nodeOffsetStart,nodeOffsetEnd}=lengths[i];if(lengthLessThan(nodeOffsetStart,position)){const result=getFirstBracketBefore(node.children[i],nodeOffsetStart,nodeOffsetEnd,position);if(result)return result}}return null}if(3===node.kind)return null;if(1===node.kind){const range=lengthsToRange(nodeOffsetStart,nodeOffsetEnd);return{bracketInfo:node.bracketInfo,range}}return null}function getFirstBracketAfter(node,nodeOffsetStart,nodeOffsetEnd,position){if(4===node.kind||2===node.kind){for(const child of node.children){if(nodeOffsetEnd=lengthAdd(nodeOffsetStart,child.length),lengthLessThan(position,nodeOffsetEnd)){const result=getFirstBracketAfter(child,nodeOffsetStart,nodeOffsetEnd,position);if(result)return result}nodeOffsetStart=nodeOffsetEnd}return null}if(3===node.kind)return null;if(1===node.kind){const range=lengthsToRange(nodeOffsetStart,nodeOffsetEnd);return{bracketInfo:node.bracketInfo,range}}return null}function collectBrackets(node,nodeOffsetStart,nodeOffsetEnd,startOffset,endOffset,result,level,levelPerBracketType){if(!(level>200))if(4===node.kind)for(const child of node.children)nodeOffsetEnd=lengthAdd(nodeOffsetStart,child.length),lengthLessThanEqual(nodeOffsetStart,endOffset)&&lengthGreaterThanEqual(nodeOffsetEnd,startOffset)&&collectBrackets(child,nodeOffsetStart,nodeOffsetEnd,startOffset,endOffset,result,level,levelPerBracketType),nodeOffsetStart=nodeOffsetEnd;else if(2===node.kind){let levelPerBracket=0;if(levelPerBracketType){let existing=levelPerBracketType.get(node.openingBracket.text);void 0===existing&&(existing=0),levelPerBracket=existing,existing++,levelPerBracketType.set(node.openingBracket.text,existing)}{const child=node.openingBracket;if(nodeOffsetEnd=lengthAdd(nodeOffsetStart,child.length),lengthLessThanEqual(nodeOffsetStart,endOffset)&&lengthGreaterThanEqual(nodeOffsetEnd,startOffset)){const range=lengthsToRange(nodeOffsetStart,nodeOffsetEnd);result.push(new BracketInfo(range,level,levelPerBracket,!node.closingBracket))}nodeOffsetStart=nodeOffsetEnd}if(node.child){const child=node.child;nodeOffsetEnd=lengthAdd(nodeOffsetStart,child.length),lengthLessThanEqual(nodeOffsetStart,endOffset)&&lengthGreaterThanEqual(nodeOffsetEnd,startOffset)&&collectBrackets(child,nodeOffsetStart,nodeOffsetEnd,startOffset,endOffset,result,level+1,levelPerBracketType),nodeOffsetStart=nodeOffsetEnd}if(node.closingBracket){const child=node.closingBracket;if(nodeOffsetEnd=lengthAdd(nodeOffsetStart,child.length),lengthLessThanEqual(nodeOffsetStart,endOffset)&&lengthGreaterThanEqual(nodeOffsetEnd,startOffset)){const range=lengthsToRange(nodeOffsetStart,nodeOffsetEnd);result.push(new BracketInfo(range,level,levelPerBracket,!1))}nodeOffsetStart=nodeOffsetEnd}null==levelPerBracketType||levelPerBracketType.set(node.openingBracket.text,levelPerBracket)}else if(3===node.kind){const range=lengthsToRange(nodeOffsetStart,nodeOffsetEnd);result.push(new BracketInfo(range,level-1,0,!0))}else if(1===node.kind){const range=lengthsToRange(nodeOffsetStart,nodeOffsetEnd);result.push(new BracketInfo(range,level-1,0,!1))}}class CollectBracketPairsContext{constructor(result,includeMinIndentation,textModel){this.result=result,this.includeMinIndentation=includeMinIndentation,this.textModel=textModel}}function collectBracketPairs(node,nodeOffsetStart,nodeOffsetEnd,startOffset,endOffset,context,level,levelPerBracketType){var _a;if(!(level>200))if(2===node.kind){let levelPerBracket=0;if(levelPerBracketType){let existing=levelPerBracketType.get(node.openingBracket.text);void 0===existing&&(existing=0),levelPerBracket=existing,existing++,levelPerBracketType.set(node.openingBracket.text,existing)}const openingBracketEnd=lengthAdd(nodeOffsetStart,node.openingBracket.length);let minIndentation=-1;if(context.includeMinIndentation&&(minIndentation=node.computeMinIndentation(nodeOffsetStart,context.textModel)),context.result.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart,nodeOffsetEnd),lengthsToRange(nodeOffsetStart,openingBracketEnd),node.closingBracket?lengthsToRange(lengthAdd(openingBracketEnd,(null===(_a=node.child)||void 0===_a?void 0:_a.length)||lengthZero),nodeOffsetEnd):void 0,level,levelPerBracket,node,minIndentation)),nodeOffsetStart=openingBracketEnd,node.child){const child=node.child;nodeOffsetEnd=lengthAdd(nodeOffsetStart,child.length),lengthLessThanEqual(nodeOffsetStart,endOffset)&&lengthGreaterThanEqual(nodeOffsetEnd,startOffset)&&collectBracketPairs(child,nodeOffsetStart,nodeOffsetEnd,startOffset,endOffset,context,level+1,levelPerBracketType)}null==levelPerBracketType||levelPerBracketType.set(node.openingBracket.text,levelPerBracket)}else{let curOffset=nodeOffsetStart;for(const child of node.children){const childOffset=curOffset;curOffset=lengthAdd(curOffset,child.length),lengthLessThanEqual(childOffset,endOffset)&&lengthLessThanEqual(startOffset,curOffset)&&collectBracketPairs(child,childOffset,curOffset,startOffset,endOffset,context,level,levelPerBracketType)}}}