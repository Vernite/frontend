import{InvalidBracketAstNode,ListAstNode,PairAstNode}from"./ast.js";import{BeforeEditPositionMapper}from"./beforeEditPositionMapper.js";import{SmallImmutableSet}from"./smallImmutableSet.js";import{lengthIsZero,lengthLessThan}from"./length.js";import{concat23Trees,concat23TreesOfSameHeight}from"./concat23Trees.js";import{NodeReader}from"./nodeReader.js";export function parseDocument(tokenizer,edits,oldNode,createImmutableLists){return new Parser(tokenizer,edits,oldNode,createImmutableLists).parseDocument()}class Parser{constructor(tokenizer,edits,oldNode,createImmutableLists){if(this.tokenizer=tokenizer,this.createImmutableLists=createImmutableLists,this._itemsConstructed=0,this._itemsFromCache=0,oldNode&&createImmutableLists)throw new Error("Not supported");this.oldNodeReader=oldNode?new NodeReader(oldNode):void 0,this.positionMapper=new BeforeEditPositionMapper(edits,tokenizer.length)}parseDocument(){this._itemsConstructed=0,this._itemsFromCache=0;let result=this.parseList(SmallImmutableSet.getEmpty());return result||(result=ListAstNode.getEmpty()),result}parseList(openedBracketIds){const items=new Array;for(;;){const token=this.tokenizer.peek();if(!token||2===token.kind&&token.bracketIds.intersects(openedBracketIds))break;const child=this.parseChild(openedBracketIds);4===child.kind&&0===child.childrenLength||items.push(child)}return this.oldNodeReader?concat23Trees(items):concat23TreesOfSameHeight(items,this.createImmutableLists)}parseChild(openedBracketIds){if(this.oldNodeReader){const maxCacheableLength=this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);if(!lengthIsZero(maxCacheableLength)){const cachedNode=this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset),(curNode=>{if(!lengthLessThan(curNode.length,maxCacheableLength))return!1;return curNode.canBeReused(openedBracketIds)}));if(cachedNode)return this._itemsFromCache++,this.tokenizer.skip(cachedNode.length),cachedNode}}this._itemsConstructed++;const token=this.tokenizer.read();switch(token.kind){case 2:return new InvalidBracketAstNode(token.bracketIds,token.length);case 0:return token.astNode;case 1:{const set=openedBracketIds.merge(token.bracketIds),child=this.parseList(set),nextToken=this.tokenizer.peek();return nextToken&&2===nextToken.kind&&(nextToken.bracketId===token.bracketId||nextToken.bracketIds.intersects(token.bracketIds))?(this.tokenizer.read(),PairAstNode.create(token.astNode,child,nextToken.astNode)):PairAstNode.create(token.astNode,child,null)}default:throw new Error("unexpected")}}}