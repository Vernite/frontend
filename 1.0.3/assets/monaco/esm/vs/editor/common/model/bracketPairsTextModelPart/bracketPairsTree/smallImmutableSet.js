const emptyArr=new Array;export class SmallImmutableSet{constructor(items,additionalItems){this.items=items,this.additionalItems=additionalItems}static create(items,additionalItems){if(items<=128&&0===additionalItems.length){let cached=SmallImmutableSet.cache[items];return cached||(cached=new SmallImmutableSet(items,additionalItems),SmallImmutableSet.cache[items]=cached),cached}return new SmallImmutableSet(items,additionalItems)}static getEmpty(){return this.empty}add(value,keyProvider){const key=keyProvider.getKey(value);let idx=key>>5;if(0===idx){const newItem=1<<key|this.items;return newItem===this.items?this:SmallImmutableSet.create(newItem,this.additionalItems)}idx--;const newItems=this.additionalItems.slice(0);for(;newItems.length<idx;)newItems.push(0);return newItems[idx]|=1<<(31&key),SmallImmutableSet.create(this.items,newItems)}merge(other){const merged=this.items|other.items;if(this.additionalItems===emptyArr&&other.additionalItems===emptyArr)return merged===this.items?this:merged===other.items?other:SmallImmutableSet.create(merged,emptyArr);const newItems=new Array;for(let i=0;i<Math.max(this.additionalItems.length,other.additionalItems.length);i++){const item1=this.additionalItems[i]||0,item2=other.additionalItems[i]||0;newItems.push(item1|item2)}return SmallImmutableSet.create(merged,newItems)}intersects(other){if(0!=(this.items&other.items))return!0;for(let i=0;i<Math.min(this.additionalItems.length,other.additionalItems.length);i++)if(0!=(this.additionalItems[i]&other.additionalItems[i]))return!0;return!1}}SmallImmutableSet.cache=new Array(129),SmallImmutableSet.empty=SmallImmutableSet.create(0,emptyArr);export const identityKeyProvider={getKey:value=>value};export class DenseKeyProvider{constructor(){this.items=new Map}getKey(value){let existing=this.items.get(value);return void 0===existing&&(existing=this.items.size,this.items.set(value,existing)),existing}}