import{Emitter}from"../../../../base/common/event.js";import{FoldingRegions}from"./foldingRanges.js";import{hash}from"../../../../base/common/hash.js";export class FoldingModel{constructor(textModel,decorationProvider){this._updateEventEmitter=new Emitter,this.onDidChange=this._updateEventEmitter.event,this._textModel=textModel,this._decorationProvider=decorationProvider,this._regions=new FoldingRegions(new Uint32Array(0),new Uint32Array(0)),this._editorDecorationIds=[]}get regions(){return this._regions}get textModel(){return this._textModel}toggleCollapseState(toggledRegions){if(!toggledRegions.length)return;toggledRegions=toggledRegions.sort(((r1,r2)=>r1.regionIndex-r2.regionIndex));const processed={};this._decorationProvider.changeDecorations((accessor=>{let k=0,dirtyRegionEndLine=-1,lastHiddenLine=-1;const updateDecorationsUntil=index=>{for(;k<index;){const endLineNumber=this._regions.getEndLineNumber(k),isCollapsed=this._regions.isCollapsed(k);if(endLineNumber<=dirtyRegionEndLine){const isManual=0!==this.regions.getSource(k);accessor.changeDecorationOptions(this._editorDecorationIds[k],this._decorationProvider.getDecorationOption(isCollapsed,endLineNumber<=lastHiddenLine,isManual))}isCollapsed&&endLineNumber>lastHiddenLine&&(lastHiddenLine=endLineNumber),k++}};for(const region of toggledRegions){const index=region.regionIndex,editorDecorationId=this._editorDecorationIds[index];if(editorDecorationId&&!processed[editorDecorationId]){processed[editorDecorationId]=!0,updateDecorationsUntil(index);const newCollapseState=!this._regions.isCollapsed(index);this._regions.setCollapsed(index,newCollapseState),dirtyRegionEndLine=Math.max(dirtyRegionEndLine,this._regions.getEndLineNumber(index))}}updateDecorationsUntil(this._regions.length)})),this._updateEventEmitter.fire({model:this,collapseStateChanged:toggledRegions})}removeManualRanges(ranges){const newFoldingRanges=new Array,intersects=foldRange=>{for(const range of ranges)if(!(range.startLineNumber>foldRange.endLineNumber||foldRange.startLineNumber>range.endLineNumber))return!0;return!1};for(let i=0;i<this._regions.length;i++){const foldRange=this._regions.toFoldRange(i);0!==foldRange.source&&intersects(foldRange)||newFoldingRanges.push(foldRange)}this.updatePost(FoldingRegions.fromFoldRanges(newFoldingRanges))}update(newRegions,blockedLineNumers=[]){const foldedOrManualRanges=this._currentFoldedOrManualRanges(blockedLineNumers),newRanges=FoldingRegions.sanitizeAndMerge(newRegions,foldedOrManualRanges,this._textModel.getLineCount());this.updatePost(FoldingRegions.fromFoldRanges(newRanges))}updatePost(newRegions){const newEditorDecorations=[];let lastHiddenLine=-1;for(let index=0,limit=newRegions.length;index<limit;index++){const startLineNumber=newRegions.getStartLineNumber(index),endLineNumber=newRegions.getEndLineNumber(index),isCollapsed=newRegions.isCollapsed(index),isManual=0!==newRegions.getSource(index),decorationRange={startLineNumber,startColumn:this._textModel.getLineMaxColumn(startLineNumber),endLineNumber,endColumn:this._textModel.getLineMaxColumn(endLineNumber)+1};newEditorDecorations.push({range:decorationRange,options:this._decorationProvider.getDecorationOption(isCollapsed,endLineNumber<=lastHiddenLine,isManual)}),isCollapsed&&endLineNumber>lastHiddenLine&&(lastHiddenLine=endLineNumber)}this._decorationProvider.changeDecorations((accessor=>this._editorDecorationIds=accessor.deltaDecorations(this._editorDecorationIds,newEditorDecorations))),this._regions=newRegions,this._updateEventEmitter.fire({model:this})}_currentFoldedOrManualRanges(blockedLineNumers=[]){const isBlocked=(startLineNumber,endLineNumber)=>{for(const blockedLineNumber of blockedLineNumers)if(startLineNumber<blockedLineNumber&&blockedLineNumber<=endLineNumber)return!0;return!1},foldedRanges=[];for(let i=0,limit=this._regions.length;i<limit;i++){let isCollapsed=this.regions.isCollapsed(i);const source=this.regions.getSource(i);if(isCollapsed||0!==source){const foldRange=this._regions.toFoldRange(i),decRange=this._textModel.getDecorationRange(this._editorDecorationIds[i]);decRange&&(isCollapsed&&(isBlocked(decRange.startLineNumber,decRange.endLineNumber)||decRange.endLineNumber-decRange.startLineNumber!=foldRange.endLineNumber-foldRange.startLineNumber)&&(isCollapsed=!1),foldedRanges.push({startLineNumber:decRange.startLineNumber,endLineNumber:decRange.endLineNumber,type:foldRange.type,isCollapsed,source}))}}return foldedRanges}getMemento(){const foldedOrManualRanges=this._currentFoldedOrManualRanges(),result=[];for(let i=0,limit=foldedOrManualRanges.length;i<limit;i++){const range=foldedOrManualRanges[i],checksum=this._getLinesChecksum(range.startLineNumber+1,range.endLineNumber);result.push({startLineNumber:range.startLineNumber,endLineNumber:range.endLineNumber,isCollapsed:range.isCollapsed,source:range.source,checksum})}return result.length>0?result:void 0}applyMemento(state){var _a,_b;if(!Array.isArray(state))return;const rangesToRestore=[],maxLineNumber=this._textModel.getLineCount();for(const range of state){if(range.startLineNumber>=range.endLineNumber||range.startLineNumber<1||range.endLineNumber>maxLineNumber)continue;const checksum=this._getLinesChecksum(range.startLineNumber+1,range.endLineNumber);range.checksum&&checksum!==range.checksum||rangesToRestore.push({startLineNumber:range.startLineNumber,endLineNumber:range.endLineNumber,type:void 0,isCollapsed:null===(_a=range.isCollapsed)||void 0===_a||_a,source:null!==(_b=range.source)&&void 0!==_b?_b:0})}const newRanges=FoldingRegions.sanitizeAndMerge(this._regions,rangesToRestore,maxLineNumber);this.updatePost(FoldingRegions.fromFoldRanges(newRanges))}_getLinesChecksum(lineNumber1,lineNumber2){return hash(this._textModel.getLineContent(lineNumber1)+this._textModel.getLineContent(lineNumber2))%1e6}dispose(){this._decorationProvider.removeDecorations(this._editorDecorationIds)}getAllRegionsAtLine(lineNumber,filter){const result=[];if(this._regions){let index=this._regions.findRange(lineNumber),level=1;for(;index>=0;){const current=this._regions.toRegion(index);filter&&!filter(current,level)||result.push(current),level++,index=current.parentIndex}}return result}getRegionAtLine(lineNumber){if(this._regions){const index=this._regions.findRange(lineNumber);if(index>=0)return this._regions.toRegion(index)}return null}getRegionsInside(region,filter){const result=[],index=region?region.regionIndex+1:0,endLineNumber=region?region.endLineNumber:Number.MAX_VALUE;if(filter&&2===filter.length){const levelStack=[];for(let i=index,len=this._regions.length;i<len;i++){const current=this._regions.toRegion(i);if(!(this._regions.getStartLineNumber(i)<endLineNumber))break;for(;levelStack.length>0&&!current.containedBy(levelStack[levelStack.length-1]);)levelStack.pop();levelStack.push(current),filter(current,levelStack.length)&&result.push(current)}}else for(let i=index,len=this._regions.length;i<len;i++){const current=this._regions.toRegion(i);if(!(this._regions.getStartLineNumber(i)<endLineNumber))break;filter&&!filter(current)||result.push(current)}return result}}export function toggleCollapseState(foldingModel,levels,lineNumbers){const toToggle=[];for(const lineNumber of lineNumbers){const region=foldingModel.getRegionAtLine(lineNumber);if(region){const doCollapse=!region.isCollapsed;if(toToggle.push(region),levels>1){const regionsInside=foldingModel.getRegionsInside(region,((r,level)=>r.isCollapsed!==doCollapse&&level<levels));toToggle.push(...regionsInside)}}}foldingModel.toggleCollapseState(toToggle)}export function setCollapseStateLevelsDown(foldingModel,doCollapse,levels=Number.MAX_VALUE,lineNumbers){const toToggle=[];if(lineNumbers&&lineNumbers.length>0)for(const lineNumber of lineNumbers){const region=foldingModel.getRegionAtLine(lineNumber);if(region&&(region.isCollapsed!==doCollapse&&toToggle.push(region),levels>1)){const regionsInside=foldingModel.getRegionsInside(region,((r,level)=>r.isCollapsed!==doCollapse&&level<levels));toToggle.push(...regionsInside)}}else{const regionsInside=foldingModel.getRegionsInside(null,((r,level)=>r.isCollapsed!==doCollapse&&level<levels));toToggle.push(...regionsInside)}foldingModel.toggleCollapseState(toToggle)}export function setCollapseStateLevelsUp(foldingModel,doCollapse,levels,lineNumbers){const toToggle=[];for(const lineNumber of lineNumbers){const regions=foldingModel.getAllRegionsAtLine(lineNumber,((region,level)=>region.isCollapsed!==doCollapse&&level<=levels));toToggle.push(...regions)}foldingModel.toggleCollapseState(toToggle)}export function setCollapseStateUp(foldingModel,doCollapse,lineNumbers){const toToggle=[];for(const lineNumber of lineNumbers){const regions=foldingModel.getAllRegionsAtLine(lineNumber,(region=>region.isCollapsed!==doCollapse));regions.length>0&&toToggle.push(regions[0])}foldingModel.toggleCollapseState(toToggle)}export function setCollapseStateAtLevel(foldingModel,foldLevel,doCollapse,blockedLineNumbers){const toToggle=foldingModel.getRegionsInside(null,((region,level)=>level===foldLevel&&region.isCollapsed!==doCollapse&&!blockedLineNumbers.some((line=>region.containsLine(line)))));foldingModel.toggleCollapseState(toToggle)}export function setCollapseStateForRest(foldingModel,doCollapse,blockedLineNumbers){const filteredRegions=[];for(const lineNumber of blockedLineNumbers){const regions=foldingModel.getAllRegionsAtLine(lineNumber,void 0);regions.length>0&&filteredRegions.push(regions[0])}const toToggle=foldingModel.getRegionsInside(null,(region=>filteredRegions.every((filteredRegion=>!filteredRegion.containedBy(region)&&!region.containedBy(filteredRegion)))&&region.isCollapsed!==doCollapse));foldingModel.toggleCollapseState(toToggle)}export function setCollapseStateForMatchingLines(foldingModel,regExp,doCollapse){const editorModel=foldingModel.textModel,regions=foldingModel.regions,toToggle=[];for(let i=regions.length-1;i>=0;i--)if(doCollapse!==regions.isCollapsed(i)){const startLineNumber=regions.getStartLineNumber(i);regExp.test(editorModel.getLineContent(startLineNumber))&&toToggle.push(regions.toRegion(i))}foldingModel.toggleCollapseState(toToggle)}export function setCollapseStateForType(foldingModel,type,doCollapse){const regions=foldingModel.regions,toToggle=[];for(let i=regions.length-1;i>=0;i--)doCollapse!==regions.isCollapsed(i)&&type===regions.getType(i)&&toToggle.push(regions.toRegion(i));foldingModel.toggleCollapseState(toToggle)}export function getParentFoldLine(lineNumber,foldingModel){let startLineNumber=null;const foldingRegion=foldingModel.getRegionAtLine(lineNumber);if(null!==foldingRegion&&(startLineNumber=foldingRegion.startLineNumber,lineNumber===startLineNumber)){const parentFoldingIdx=foldingRegion.parentIndex;startLineNumber=-1!==parentFoldingIdx?foldingModel.regions.getStartLineNumber(parentFoldingIdx):null}return startLineNumber}export function getPreviousFoldLine(lineNumber,foldingModel){let foldingRegion=foldingModel.getRegionAtLine(lineNumber);if(null!==foldingRegion&&foldingRegion.startLineNumber===lineNumber){if(lineNumber!==foldingRegion.startLineNumber)return foldingRegion.startLineNumber;{const expectedParentIndex=foldingRegion.parentIndex;let minLineNumber=0;for(-1!==expectedParentIndex&&(minLineNumber=foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex));null!==foldingRegion;){if(!(foldingRegion.regionIndex>0))return null;if(foldingRegion=foldingModel.regions.toRegion(foldingRegion.regionIndex-1),foldingRegion.startLineNumber<=minLineNumber)return null;if(foldingRegion.parentIndex===expectedParentIndex)return foldingRegion.startLineNumber}}}else if(foldingModel.regions.length>0)for(foldingRegion=foldingModel.regions.toRegion(foldingModel.regions.length-1);null!==foldingRegion;){if(foldingRegion.startLineNumber<lineNumber)return foldingRegion.startLineNumber;foldingRegion=foldingRegion.regionIndex>0?foldingModel.regions.toRegion(foldingRegion.regionIndex-1):null}return null}export function getNextFoldLine(lineNumber,foldingModel){let foldingRegion=foldingModel.getRegionAtLine(lineNumber);if(null!==foldingRegion&&foldingRegion.startLineNumber===lineNumber){const expectedParentIndex=foldingRegion.parentIndex;let maxLineNumber=0;if(-1!==expectedParentIndex)maxLineNumber=foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);else{if(0===foldingModel.regions.length)return null;maxLineNumber=foldingModel.regions.getEndLineNumber(foldingModel.regions.length-1)}for(;null!==foldingRegion;){if(!(foldingRegion.regionIndex<foldingModel.regions.length))return null;if(foldingRegion=foldingModel.regions.toRegion(foldingRegion.regionIndex+1),foldingRegion.startLineNumber>=maxLineNumber)return null;if(foldingRegion.parentIndex===expectedParentIndex)return foldingRegion.startLineNumber}}else if(foldingModel.regions.length>0)for(foldingRegion=foldingModel.regions.toRegion(0);null!==foldingRegion;){if(foldingRegion.startLineNumber>lineNumber)return foldingRegion.startLineNumber;foldingRegion=foldingRegion.regionIndex<foldingModel.regions.length?foldingModel.regions.toRegion(foldingRegion.regionIndex+1):null}return null}