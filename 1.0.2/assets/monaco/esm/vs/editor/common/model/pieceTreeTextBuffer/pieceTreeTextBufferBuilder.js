import*as strings from"../../../../base/common/strings.js";import{StringBuffer,createLineStarts,createLineStartsFast}from"./pieceTreeBase.js";import{PieceTreeTextBuffer}from"./pieceTreeTextBuffer.js";export class PieceTreeTextBufferFactory{constructor(_chunks,_bom,_cr,_lf,_crlf,_containsRTL,_containsUnusualLineTerminators,_isBasicASCII,_normalizeEOL){this._chunks=_chunks,this._bom=_bom,this._cr=_cr,this._lf=_lf,this._crlf=_crlf,this._containsRTL=_containsRTL,this._containsUnusualLineTerminators=_containsUnusualLineTerminators,this._isBasicASCII=_isBasicASCII,this._normalizeEOL=_normalizeEOL}_getEOL(defaultEOL){const totalEOLCount=this._cr+this._lf+this._crlf,totalCRCount=this._cr+this._crlf;return 0===totalEOLCount?1===defaultEOL?"\n":"\r\n":totalCRCount>totalEOLCount/2?"\r\n":"\n"}create(defaultEOL){const eol=this._getEOL(defaultEOL),chunks=this._chunks;if(this._normalizeEOL&&("\r\n"===eol&&(this._cr>0||this._lf>0)||"\n"===eol&&(this._cr>0||this._crlf>0)))for(let i=0,len=chunks.length;i<len;i++){const str=chunks[i].buffer.replace(/\r\n|\r|\n/g,eol),newLineStart=createLineStartsFast(str);chunks[i]=new StringBuffer(str,newLineStart)}const textBuffer=new PieceTreeTextBuffer(chunks,this._bom,eol,this._containsRTL,this._containsUnusualLineTerminators,this._isBasicASCII,this._normalizeEOL);return{textBuffer,disposable:textBuffer}}}export class PieceTreeTextBufferBuilder{constructor(){this.chunks=[],this.BOM="",this._hasPreviousChar=!1,this._previousChar=0,this._tmpLineStarts=[],this.cr=0,this.lf=0,this.crlf=0,this.containsRTL=!1,this.containsUnusualLineTerminators=!1,this.isBasicASCII=!0}acceptChunk(chunk){if(0===chunk.length)return;0===this.chunks.length&&strings.startsWithUTF8BOM(chunk)&&(this.BOM=strings.UTF8_BOM_CHARACTER,chunk=chunk.substr(1));const lastChar=chunk.charCodeAt(chunk.length-1);13===lastChar||lastChar>=55296&&lastChar<=56319?(this._acceptChunk1(chunk.substr(0,chunk.length-1),!1),this._hasPreviousChar=!0,this._previousChar=lastChar):(this._acceptChunk1(chunk,!1),this._hasPreviousChar=!1,this._previousChar=lastChar)}_acceptChunk1(chunk,allowEmptyStrings){(allowEmptyStrings||0!==chunk.length)&&(this._hasPreviousChar?this._acceptChunk2(String.fromCharCode(this._previousChar)+chunk):this._acceptChunk2(chunk))}_acceptChunk2(chunk){const lineStarts=createLineStarts(this._tmpLineStarts,chunk);this.chunks.push(new StringBuffer(chunk,lineStarts.lineStarts)),this.cr+=lineStarts.cr,this.lf+=lineStarts.lf,this.crlf+=lineStarts.crlf,this.isBasicASCII&&(this.isBasicASCII=lineStarts.isBasicASCII),this.isBasicASCII||this.containsRTL||(this.containsRTL=strings.containsRTL(chunk)),this.isBasicASCII||this.containsUnusualLineTerminators||(this.containsUnusualLineTerminators=strings.containsUnusualLineTerminators(chunk))}finish(normalizeEOL=!0){return this._finish(),new PieceTreeTextBufferFactory(this.chunks,this.BOM,this.cr,this.lf,this.crlf,this.containsRTL,this.containsUnusualLineTerminators,this.isBasicASCII,normalizeEOL)}_finish(){if(0===this.chunks.length&&this._acceptChunk1("",!0),this._hasPreviousChar){this._hasPreviousChar=!1;const lastChunk=this.chunks[this.chunks.length-1];lastChunk.buffer+=String.fromCharCode(this._previousChar);const newLineStarts=createLineStartsFast(lastChunk.buffer);lastChunk.lineStarts=newLineStarts,13===this._previousChar&&this.cr++}}}