import{computeIndentLevel}from"../../../common/model/utils.js";import{FoldingRegions,MAX_LINE_NUMBER}from"./foldingRanges.js";const MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT=5e3;export const ID_INDENT_PROVIDER="indent";export class IndentRangeProvider{constructor(editorModel,languageConfigurationService,maxFoldingRegions){this.editorModel=editorModel,this.languageConfigurationService=languageConfigurationService,this.maxFoldingRegions=maxFoldingRegions,this.id="indent"}dispose(){}compute(cancelationToken,notifyTooManyRegions){const foldingRules=this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules,offSide=foldingRules&&!!foldingRules.offSide,markers=foldingRules&&foldingRules.markers;return Promise.resolve(computeRanges(this.editorModel,offSide,markers,this.maxFoldingRegions,notifyTooManyRegions))}}export class RangesCollector{constructor(foldingRangesLimit,_notifyTooManyRegions){this._notifyTooManyRegions=_notifyTooManyRegions,this._startIndexes=[],this._endIndexes=[],this._indentOccurrences=[],this._length=0,this._foldingRangesLimit=foldingRangesLimit}insertFirst(startLineNumber,endLineNumber,indent){if(startLineNumber>MAX_LINE_NUMBER||endLineNumber>MAX_LINE_NUMBER)return;const index=this._length;this._startIndexes[index]=startLineNumber,this._endIndexes[index]=endLineNumber,this._length++,indent<1e3&&(this._indentOccurrences[indent]=(this._indentOccurrences[indent]||0)+1)}toIndentRanges(model){var _a;if(this._length<=this._foldingRangesLimit){const startIndexes=new Uint32Array(this._length),endIndexes=new Uint32Array(this._length);for(let i=this._length-1,k=0;i>=0;i--,k++)startIndexes[k]=this._startIndexes[i],endIndexes[k]=this._endIndexes[i];return new FoldingRegions(startIndexes,endIndexes)}{null===(_a=this._notifyTooManyRegions)||void 0===_a||_a.call(this,this._foldingRangesLimit);let entries=0,maxIndent=this._indentOccurrences.length;for(let i=0;i<this._indentOccurrences.length;i++){const n=this._indentOccurrences[i];if(n){if(n+entries>this._foldingRangesLimit){maxIndent=i;break}entries+=n}}const tabSize=model.getOptions().tabSize,startIndexes=new Uint32Array(this._foldingRangesLimit),endIndexes=new Uint32Array(this._foldingRangesLimit);for(let i=this._length-1,k=0;i>=0;i--){const startIndex=this._startIndexes[i],lineContent=model.getLineContent(startIndex),indent=computeIndentLevel(lineContent,tabSize);(indent<maxIndent||indent===maxIndent&&entries++<this._foldingRangesLimit)&&(startIndexes[k]=startIndex,endIndexes[k]=this._endIndexes[i],k++)}return new FoldingRegions(startIndexes,endIndexes)}}}export function computeRanges(model,offSide,markers,foldingRangesLimit,notifyTooManyRegions){const tabSize=model.getOptions().tabSize,result=new RangesCollector(foldingRangesLimit=null!=foldingRangesLimit?foldingRangesLimit:5e3,notifyTooManyRegions);let pattern;markers&&(pattern=new RegExp(`(${markers.start.source})|(?:${markers.end.source})`));const previousRegions=[],line=model.getLineCount()+1;previousRegions.push({indent:-1,endAbove:line,line});for(let line=model.getLineCount();line>0;line--){const lineContent=model.getLineContent(line),indent=computeIndentLevel(lineContent,tabSize);let m,previous=previousRegions[previousRegions.length-1];if(-1!==indent){if(pattern&&(m=lineContent.match(pattern))){if(!m[1]){previousRegions.push({indent:-2,endAbove:line,line});continue}{let i=previousRegions.length-1;for(;i>0&&-2!==previousRegions[i].indent;)i--;if(i>0){previousRegions.length=i+1,previous=previousRegions[i],result.insertFirst(line,previous.line,indent),previous.line=line,previous.indent=indent,previous.endAbove=line;continue}}}if(previous.indent>indent){do{previousRegions.pop(),previous=previousRegions[previousRegions.length-1]}while(previous.indent>indent);const endLineNumber=previous.endAbove-1;endLineNumber-line>=1&&result.insertFirst(line,endLineNumber,indent)}previous.indent===indent?previous.endAbove=line:previousRegions.push({indent,endAbove:line,line})}else offSide&&(previous.endAbove=line)}return result.toIndentRanges(model)}