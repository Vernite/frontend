var __decorate=this&&this.__decorate||function(decorators,target,key,desc){var d,c=arguments.length,r=c<3?target:null===desc?desc=Object.getOwnPropertyDescriptor(target,key):desc;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(decorators,target,key,desc);else for(var i=decorators.length-1;i>=0;i--)(d=decorators[i])&&(r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r);return c>3&&r&&Object.defineProperty(target,key,r),r},__param=this&&this.__param||function(paramIndex,decorator){return function(target,key){decorator(target,key,paramIndex)}};import{RunOnceScheduler}from"../../../base/common/async.js";import{Emitter}from"../../../base/common/event.js";import{DisposableStore}from"../../../base/common/lifecycle.js";import{IMenuService,isIMenuItem,MenuItemAction,MenuRegistry,SubmenuItemAction}from"./actions.js";import{ICommandService}from"../../commands/common/commands.js";import{IContextKeyService}from"../../contextkey/common/contextkey.js";import{toAction}from"../../../base/common/actions.js";import{IStorageService}from"../../storage/common/storage.js";import{removeFastWithoutKeepingOrder}from"../../../base/common/arrays.js";import{localize}from"../../../nls.js";let MenuService=class MenuService{constructor(_commandService,storageService){this._commandService=_commandService,this._hiddenStates=new PersistedMenuHideState(storageService)}createMenu(id,contextKeyService,options){return new Menu(id,this._hiddenStates,Object.assign({emitEventsForSubmenuChanges:!1,eventDebounceDelay:50},options),this._commandService,contextKeyService,this)}};MenuService=__decorate([__param(0,ICommandService),__param(1,IStorageService)],MenuService);export{MenuService};let PersistedMenuHideState=class PersistedMenuHideState{constructor(_storageService){this._storageService=_storageService,this._disposables=new DisposableStore,this._onDidChange=new Emitter,this.onDidChange=this._onDidChange.event,this._ignoreChangeEvent=!1;try{const raw=_storageService.get(PersistedMenuHideState._key,0,"{}");this._data=JSON.parse(raw)}catch(err){this._data=Object.create(null)}this._disposables.add(_storageService.onDidChangeValue((e=>{if(e.key===PersistedMenuHideState._key){if(!this._ignoreChangeEvent)try{const raw=_storageService.get(PersistedMenuHideState._key,0,"{}");this._data=JSON.parse(raw)}catch(err){console.log("FAILED to read storage after UPDATE",err)}this._onDidChange.fire()}})))}dispose(){this._onDidChange.dispose(),this._disposables.dispose()}isHidden(menu,commandId){var _a,_b;return null!==(_b=null===(_a=this._data[menu.id])||void 0===_a?void 0:_a.includes(commandId))&&void 0!==_b&&_b}updateHidden(menu,commandId,hidden){const entries=this._data[menu.id];if(hidden)if(entries){entries.indexOf(commandId)<0&&entries.push(commandId)}else this._data[menu.id]=[commandId];else if(entries){const idx=entries.indexOf(commandId);idx>=0&&removeFastWithoutKeepingOrder(entries,idx),0===entries.length&&delete this._data[menu.id]}this._persist()}_persist(){try{this._ignoreChangeEvent=!0;const raw=JSON.stringify(this._data);this._storageService.store(PersistedMenuHideState._key,raw,0,0)}finally{this._ignoreChangeEvent=!1}}};PersistedMenuHideState._key="menu.hiddenCommands",PersistedMenuHideState=__decorate([__param(0,IStorageService)],PersistedMenuHideState);let Menu=class Menu{constructor(_id,_hiddenStates,_options,_commandService,_contextKeyService,_menuService){this._id=_id,this._hiddenStates=_hiddenStates,this._options=_options,this._commandService=_commandService,this._contextKeyService=_contextKeyService,this._menuService=_menuService,this._disposables=new DisposableStore,this._menuGroups=[],this._contextKeys=new Set,this._build();const rebuildMenuSoon=new RunOnceScheduler((()=>{this._build(),this._onDidChange.fire(this)}),_options.eventDebounceDelay);this._disposables.add(rebuildMenuSoon),this._disposables.add(MenuRegistry.onDidChangeMenu((e=>{e.has(_id)&&rebuildMenuSoon.schedule()})));const lazyListener=this._disposables.add(new DisposableStore);this._onDidChange=new Emitter({onFirstListenerAdd:()=>{const fireChangeSoon=new RunOnceScheduler((()=>this._onDidChange.fire(this)),_options.eventDebounceDelay);lazyListener.add(fireChangeSoon),lazyListener.add(_contextKeyService.onDidChangeContext((e=>{e.affectsSome(this._contextKeys)&&fireChangeSoon.schedule()}))),lazyListener.add(_hiddenStates.onDidChange((()=>{fireChangeSoon.schedule()})))},onLastListenerRemove:lazyListener.clear.bind(lazyListener)}),this.onDidChange=this._onDidChange.event}dispose(){this._disposables.dispose(),this._onDidChange.dispose()}_build(){this._menuGroups.length=0,this._contextKeys.clear();const menuItems=MenuRegistry.getMenuItems(this._id);let group;menuItems.sort(Menu._compareMenuItems);for(const item of menuItems){const groupName=item.group||"";group&&group[0]===groupName||(group=[groupName,[]],this._menuGroups.push(group)),group[1].push(item),this._collectContextKeys(item)}}_collectContextKeys(item){if(Menu._fillInKbExprKeys(item.when,this._contextKeys),isIMenuItem(item)){if(item.command.precondition&&Menu._fillInKbExprKeys(item.command.precondition,this._contextKeys),item.command.toggled){const toggledExpression=item.command.toggled.condition||item.command.toggled;Menu._fillInKbExprKeys(toggledExpression,this._contextKeys)}}else this._options.emitEventsForSubmenuChanges&&MenuRegistry.getMenuItems(item.submenu).forEach(this._collectContextKeys,this)}getActions(options){const result=[],allToggleActions=[];for(const group of this._menuGroups){const[id,items]=group,toggleActions=[],activeActions=[];for(const item of items)if(this._contextKeyService.contextMatchesRules(item.when)){let action;if(isIMenuItem(item)){const menuHide=createMenuHide(this._id,item.command,this._hiddenStates);action=new MenuItemAction(item.command,item.alt,options,menuHide,this._contextKeyService,this._commandService)}else action=new SubmenuItemAction(item,this._menuService,this._contextKeyService,options),0===action.actions.length&&(action.dispose(),action=void 0);action&&activeActions.push(action)}activeActions.length>0&&result.push([id,activeActions]),toggleActions.length>0&&allToggleActions.push(toggleActions)}return result}static _fillInKbExprKeys(exp,set){if(exp)for(const key of exp.keys())set.add(key)}static _compareMenuItems(a,b){const aGroup=a.group,bGroup=b.group;if(aGroup!==bGroup){if(!aGroup)return 1;if(!bGroup)return-1;if("navigation"===aGroup)return-1;if("navigation"===bGroup)return 1;const value=aGroup.localeCompare(bGroup);if(0!==value)return value}const aPrio=a.order||0,bPrio=b.order||0;return aPrio<bPrio?-1:aPrio>bPrio?1:Menu._compareTitles(isIMenuItem(a)?a.command.title:a.title,isIMenuItem(b)?b.command.title:b.title)}static _compareTitles(a,b){const aStr="string"==typeof a?a:a.original,bStr="string"==typeof b?b:b.original;return aStr.localeCompare(bStr)}};function createMenuHide(menu,command,states){const id=`${menu.id}/${command.id}`,title="string"==typeof command.title?command.title:command.title.value,hide=toAction({id,label:localize("hide.label","Hide '{0}'",title),run(){states.updateHidden(menu,command.id,!0)}}),toggle=toAction({id,label:title,get checked(){return!states.isHidden(menu,command.id)},run(){const newValue=!states.isHidden(menu,command.id);states.updateHidden(menu,command.id,newValue)}});return{hide,toggle,get isHidden(){return!toggle.checked}}}Menu=__decorate([__param(3,ICommandService),__param(4,IContextKeyService),__param(5,IMenuService)],Menu);