import{Emitter}from"../../../../base/common/event.js";import*as strings from"../../../../base/common/strings.js";import{Range}from"../../core/range.js";import{ApplyEditsResult}from"../../model.js";import{PieceTreeBase}from"./pieceTreeBase.js";import{countEOL}from"../../core/eolCounter.js";import{TextChange}from"../../core/textChange.js";import{Disposable}from"../../../../base/common/lifecycle.js";export class PieceTreeTextBuffer extends Disposable{constructor(chunks,BOM,eol,containsRTL,containsUnusualLineTerminators,isBasicASCII,eolNormalized){super(),this._onDidChangeContent=this._register(new Emitter),this._BOM=BOM,this._mightContainNonBasicASCII=!isBasicASCII,this._mightContainRTL=containsRTL,this._mightContainUnusualLineTerminators=containsUnusualLineTerminators,this._pieceTree=new PieceTreeBase(chunks,eol,eolNormalized)}mightContainRTL(){return this._mightContainRTL}mightContainUnusualLineTerminators(){return this._mightContainUnusualLineTerminators}resetMightContainUnusualLineTerminators(){this._mightContainUnusualLineTerminators=!1}mightContainNonBasicASCII(){return this._mightContainNonBasicASCII}getBOM(){return this._BOM}getEOL(){return this._pieceTree.getEOL()}createSnapshot(preserveBOM){return this._pieceTree.createSnapshot(preserveBOM?this._BOM:"")}getOffsetAt(lineNumber,column){return this._pieceTree.getOffsetAt(lineNumber,column)}getPositionAt(offset){return this._pieceTree.getPositionAt(offset)}getRangeAt(start,length){const end=start+length,startPosition=this.getPositionAt(start),endPosition=this.getPositionAt(end);return new Range(startPosition.lineNumber,startPosition.column,endPosition.lineNumber,endPosition.column)}getValueInRange(range,eol=0){if(range.isEmpty())return"";const lineEnding=this._getEndOfLine(eol);return this._pieceTree.getValueInRange(range,lineEnding)}getValueLengthInRange(range,eol=0){if(range.isEmpty())return 0;if(range.startLineNumber===range.endLineNumber)return range.endColumn-range.startColumn;const startOffset=this.getOffsetAt(range.startLineNumber,range.startColumn);return this.getOffsetAt(range.endLineNumber,range.endColumn)-startOffset}getCharacterCountInRange(range,eol=0){if(this._mightContainNonBasicASCII){let result=0;const fromLineNumber=range.startLineNumber,toLineNumber=range.endLineNumber;for(let lineNumber=fromLineNumber;lineNumber<=toLineNumber;lineNumber++){const lineContent=this.getLineContent(lineNumber),fromOffset=lineNumber===fromLineNumber?range.startColumn-1:0,toOffset=lineNumber===toLineNumber?range.endColumn-1:lineContent.length;for(let offset=fromOffset;offset<toOffset;offset++)strings.isHighSurrogate(lineContent.charCodeAt(offset))?(result+=1,offset+=1):result+=1}return result+=this._getEndOfLine(eol).length*(toLineNumber-fromLineNumber),result}return this.getValueLengthInRange(range,eol)}getLength(){return this._pieceTree.getLength()}getLineCount(){return this._pieceTree.getLineCount()}getLinesContent(){return this._pieceTree.getLinesContent()}getLineContent(lineNumber){return this._pieceTree.getLineContent(lineNumber)}getLineCharCode(lineNumber,index){return this._pieceTree.getLineCharCode(lineNumber,index)}getLineLength(lineNumber){return this._pieceTree.getLineLength(lineNumber)}getLineFirstNonWhitespaceColumn(lineNumber){const result=strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));return-1===result?0:result+1}getLineLastNonWhitespaceColumn(lineNumber){const result=strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));return-1===result?0:result+2}_getEndOfLine(eol){switch(eol){case 1:return"\n";case 2:return"\r\n";case 0:return this.getEOL();default:throw new Error("Unknown EOL preference")}}setEOL(newEOL){this._pieceTree.setEOL(newEOL)}applyEdits(rawOperations,recordTrimAutoWhitespace,computeUndoEdits){let mightContainRTL=this._mightContainRTL,mightContainUnusualLineTerminators=this._mightContainUnusualLineTerminators,mightContainNonBasicASCII=this._mightContainNonBasicASCII,canReduceOperations=!0,operations=[];for(let i=0;i<rawOperations.length;i++){const op=rawOperations[i];canReduceOperations&&op._isTracked&&(canReduceOperations=!1);const validatedRange=op.range;if(op.text){let textMightContainNonBasicASCII=!0;mightContainNonBasicASCII||(textMightContainNonBasicASCII=!strings.isBasicASCII(op.text),mightContainNonBasicASCII=textMightContainNonBasicASCII),!mightContainRTL&&textMightContainNonBasicASCII&&(mightContainRTL=strings.containsRTL(op.text)),!mightContainUnusualLineTerminators&&textMightContainNonBasicASCII&&(mightContainUnusualLineTerminators=strings.containsUnusualLineTerminators(op.text))}let validText="",eolCount=0,firstLineLength=0,lastLineLength=0;if(op.text){let strEOL;[eolCount,firstLineLength,lastLineLength,strEOL]=countEOL(op.text);const bufferEOL=this.getEOL(),expectedStrEOL="\r\n"===bufferEOL?2:1;validText=0===strEOL||strEOL===expectedStrEOL?op.text:op.text.replace(/\r\n|\r|\n/g,bufferEOL)}operations[i]={sortIndex:i,identifier:op.identifier||null,range:validatedRange,rangeOffset:this.getOffsetAt(validatedRange.startLineNumber,validatedRange.startColumn),rangeLength:this.getValueLengthInRange(validatedRange),text:validText,eolCount,firstLineLength,lastLineLength,forceMoveMarkers:Boolean(op.forceMoveMarkers),isAutoWhitespaceEdit:op.isAutoWhitespaceEdit||!1}}operations.sort(PieceTreeTextBuffer._sortOpsAscending);let hasTouchingRanges=!1;for(let i=0,count=operations.length-1;i<count;i++){const rangeEnd=operations[i].range.getEndPosition(),nextRangeStart=operations[i+1].range.getStartPosition();if(nextRangeStart.isBeforeOrEqual(rangeEnd)){if(nextRangeStart.isBefore(rangeEnd))throw new Error("Overlapping ranges are not allowed!");hasTouchingRanges=!0}}canReduceOperations&&(operations=this._reduceOperations(operations));const reverseRanges=computeUndoEdits||recordTrimAutoWhitespace?PieceTreeTextBuffer._getInverseEditRanges(operations):[],newTrimAutoWhitespaceCandidates=[];if(recordTrimAutoWhitespace)for(let i=0;i<operations.length;i++){const op=operations[i],reverseRange=reverseRanges[i];if(op.isAutoWhitespaceEdit&&op.range.isEmpty())for(let lineNumber=reverseRange.startLineNumber;lineNumber<=reverseRange.endLineNumber;lineNumber++){let currentLineContent="";lineNumber===reverseRange.startLineNumber&&(currentLineContent=this.getLineContent(op.range.startLineNumber),-1!==strings.firstNonWhitespaceIndex(currentLineContent))||newTrimAutoWhitespaceCandidates.push({lineNumber,oldContent:currentLineContent})}}let reverseOperations=null;if(computeUndoEdits){let reverseRangeDeltaOffset=0;reverseOperations=[];for(let i=0;i<operations.length;i++){const op=operations[i],reverseRange=reverseRanges[i],bufferText=this.getValueInRange(op.range),reverseRangeOffset=op.rangeOffset+reverseRangeDeltaOffset;reverseRangeDeltaOffset+=op.text.length-bufferText.length,reverseOperations[i]={sortIndex:op.sortIndex,identifier:op.identifier,range:reverseRange,text:bufferText,textChange:new TextChange(op.rangeOffset,bufferText,reverseRangeOffset,op.text)}}hasTouchingRanges||reverseOperations.sort(((a,b)=>a.sortIndex-b.sortIndex))}this._mightContainRTL=mightContainRTL,this._mightContainUnusualLineTerminators=mightContainUnusualLineTerminators,this._mightContainNonBasicASCII=mightContainNonBasicASCII;const contentChanges=this._doApplyEdits(operations);let trimAutoWhitespaceLineNumbers=null;if(recordTrimAutoWhitespace&&newTrimAutoWhitespaceCandidates.length>0){newTrimAutoWhitespaceCandidates.sort(((a,b)=>b.lineNumber-a.lineNumber)),trimAutoWhitespaceLineNumbers=[];for(let i=0,len=newTrimAutoWhitespaceCandidates.length;i<len;i++){const lineNumber=newTrimAutoWhitespaceCandidates[i].lineNumber;if(i>0&&newTrimAutoWhitespaceCandidates[i-1].lineNumber===lineNumber)continue;const prevContent=newTrimAutoWhitespaceCandidates[i].oldContent,lineContent=this.getLineContent(lineNumber);0!==lineContent.length&&lineContent!==prevContent&&-1===strings.firstNonWhitespaceIndex(lineContent)&&trimAutoWhitespaceLineNumbers.push(lineNumber)}}return this._onDidChangeContent.fire(),new ApplyEditsResult(reverseOperations,contentChanges,trimAutoWhitespaceLineNumbers)}_reduceOperations(operations){return operations.length<1e3?operations:[this._toSingleEditOperation(operations)]}_toSingleEditOperation(operations){let forceMoveMarkers=!1;const firstEditRange=operations[0].range,lastEditRange=operations[operations.length-1].range,entireEditRange=new Range(firstEditRange.startLineNumber,firstEditRange.startColumn,lastEditRange.endLineNumber,lastEditRange.endColumn);let lastEndLineNumber=firstEditRange.startLineNumber,lastEndColumn=firstEditRange.startColumn;const result=[];for(let i=0,len=operations.length;i<len;i++){const operation=operations[i],range=operation.range;forceMoveMarkers=forceMoveMarkers||operation.forceMoveMarkers,result.push(this.getValueInRange(new Range(lastEndLineNumber,lastEndColumn,range.startLineNumber,range.startColumn))),operation.text.length>0&&result.push(operation.text),lastEndLineNumber=range.endLineNumber,lastEndColumn=range.endColumn}const text=result.join(""),[eolCount,firstLineLength,lastLineLength]=countEOL(text);return{sortIndex:0,identifier:operations[0].identifier,range:entireEditRange,rangeOffset:this.getOffsetAt(entireEditRange.startLineNumber,entireEditRange.startColumn),rangeLength:this.getValueLengthInRange(entireEditRange,0),text,eolCount,firstLineLength,lastLineLength,forceMoveMarkers,isAutoWhitespaceEdit:!1}}_doApplyEdits(operations){operations.sort(PieceTreeTextBuffer._sortOpsDescending);const contentChanges=[];for(let i=0;i<operations.length;i++){const op=operations[i],startLineNumber=op.range.startLineNumber,startColumn=op.range.startColumn,endLineNumber=op.range.endLineNumber,endColumn=op.range.endColumn;if(startLineNumber===endLineNumber&&startColumn===endColumn&&0===op.text.length)continue;op.text?(this._pieceTree.delete(op.rangeOffset,op.rangeLength),this._pieceTree.insert(op.rangeOffset,op.text,!0)):this._pieceTree.delete(op.rangeOffset,op.rangeLength);const contentChangeRange=new Range(startLineNumber,startColumn,endLineNumber,endColumn);contentChanges.push({range:contentChangeRange,rangeLength:op.rangeLength,text:op.text,rangeOffset:op.rangeOffset,forceMoveMarkers:op.forceMoveMarkers})}return contentChanges}findMatchesLineByLine(searchRange,searchData,captureMatches,limitResultCount){return this._pieceTree.findMatchesLineByLine(searchRange,searchData,captureMatches,limitResultCount)}static _getInverseEditRanges(operations){const result=[];let prevOpEndLineNumber=0,prevOpEndColumn=0,prevOp=null;for(let i=0,len=operations.length;i<len;i++){const op=operations[i];let startLineNumber,startColumn,resultRange;if(prevOp?prevOp.range.endLineNumber===op.range.startLineNumber?(startLineNumber=prevOpEndLineNumber,startColumn=prevOpEndColumn+(op.range.startColumn-prevOp.range.endColumn)):(startLineNumber=prevOpEndLineNumber+(op.range.startLineNumber-prevOp.range.endLineNumber),startColumn=op.range.startColumn):(startLineNumber=op.range.startLineNumber,startColumn=op.range.startColumn),op.text.length>0){const lineCount=op.eolCount+1;resultRange=1===lineCount?new Range(startLineNumber,startColumn,startLineNumber,startColumn+op.firstLineLength):new Range(startLineNumber,startColumn,startLineNumber+lineCount-1,op.lastLineLength+1)}else resultRange=new Range(startLineNumber,startColumn,startLineNumber,startColumn);prevOpEndLineNumber=resultRange.endLineNumber,prevOpEndColumn=resultRange.endColumn,result.push(resultRange),prevOp=op}return result}static _sortOpsAscending(a,b){const r=Range.compareRangesUsingEnds(a.range,b.range);return 0===r?a.sortIndex-b.sortIndex:r}static _sortOpsDescending(a,b){const r=Range.compareRangesUsingEnds(a.range,b.range);return 0===r?b.sortIndex-a.sortIndex:-r}}