export function getNodeColor(node){return(1&node.metadata)>>>0}function setNodeColor(node,color){node.metadata=254&node.metadata|color<<0}function getNodeIsVisited(node){return(2&node.metadata)>>>1==1}function setNodeIsVisited(node,value){node.metadata=253&node.metadata|(value?1:0)<<1}function getNodeIsForValidation(node){return(4&node.metadata)>>>2==1}function setNodeIsForValidation(node,value){node.metadata=251&node.metadata|(value?1:0)<<2}function getNodeStickiness(node){return(24&node.metadata)>>>3}function _setNodeStickiness(node,stickiness){node.metadata=231&node.metadata|stickiness<<3}function getCollapseOnReplaceEdit(node){return(32&node.metadata)>>>5==1}function setCollapseOnReplaceEdit(node,value){node.metadata=223&node.metadata|(value?1:0)<<5}export class IntervalNode{constructor(id,start,end){this.metadata=0,this.parent=this,this.left=this,this.right=this,setNodeColor(this,1),this.start=start,this.end=end,this.delta=0,this.maxEnd=end,this.id=id,this.ownerId=0,this.options=null,setNodeIsForValidation(this,!1),_setNodeStickiness(this,1),setCollapseOnReplaceEdit(this,!1),this.cachedVersionId=0,this.cachedAbsoluteStart=start,this.cachedAbsoluteEnd=end,this.range=null,setNodeIsVisited(this,!1)}reset(versionId,start,end,range){this.start=start,this.end=end,this.maxEnd=end,this.cachedVersionId=versionId,this.cachedAbsoluteStart=start,this.cachedAbsoluteEnd=end,this.range=range}setOptions(options){this.options=options;const className=this.options.className;setNodeIsForValidation(this,"squiggly-error"===className||"squiggly-warning"===className||"squiggly-info"===className),_setNodeStickiness(this,this.options.stickiness),setCollapseOnReplaceEdit(this,this.options.collapseOnReplaceEdit)}setCachedOffsets(absoluteStart,absoluteEnd,cachedVersionId){this.cachedVersionId!==cachedVersionId&&(this.range=null),this.cachedVersionId=cachedVersionId,this.cachedAbsoluteStart=absoluteStart,this.cachedAbsoluteEnd=absoluteEnd}detach(){this.parent=null,this.left=null,this.right=null}}export const SENTINEL=new IntervalNode(null,0,0);SENTINEL.parent=SENTINEL,SENTINEL.left=SENTINEL,SENTINEL.right=SENTINEL,setNodeColor(SENTINEL,0);export class IntervalTree{constructor(){this.root=SENTINEL,this.requestNormalizeDelta=!1}intervalSearch(start,end,filterOwnerId,filterOutValidation,cachedVersionId){return this.root===SENTINEL?[]:intervalSearch(this,start,end,filterOwnerId,filterOutValidation,cachedVersionId)}search(filterOwnerId,filterOutValidation,cachedVersionId){return this.root===SENTINEL?[]:search(this,filterOwnerId,filterOutValidation,cachedVersionId)}collectNodesFromOwner(ownerId){return collectNodesFromOwner(this,ownerId)}collectNodesPostOrder(){return collectNodesPostOrder(this)}insert(node){rbTreeInsert(this,node),this._normalizeDeltaIfNecessary()}delete(node){rbTreeDelete(this,node),this._normalizeDeltaIfNecessary()}resolveNode(node,cachedVersionId){const initialNode=node;let delta=0;for(;node!==this.root;)node===node.parent.right&&(delta+=node.parent.delta),node=node.parent;const nodeStart=initialNode.start+delta,nodeEnd=initialNode.end+delta;initialNode.setCachedOffsets(nodeStart,nodeEnd,cachedVersionId)}acceptReplace(offset,length,textLength,forceMoveMarkers){const nodesOfInterest=searchForEditing(this,offset,offset+length);for(let i=0,len=nodesOfInterest.length;i<len;i++){rbTreeDelete(this,nodesOfInterest[i])}this._normalizeDeltaIfNecessary(),noOverlapReplace(this,offset,offset+length,textLength),this._normalizeDeltaIfNecessary();for(let i=0,len=nodesOfInterest.length;i<len;i++){const node=nodesOfInterest[i];node.start=node.cachedAbsoluteStart,node.end=node.cachedAbsoluteEnd,nodeAcceptEdit(node,offset,offset+length,textLength,forceMoveMarkers),node.maxEnd=node.end,rbTreeInsert(this,node)}this._normalizeDeltaIfNecessary()}_normalizeDeltaIfNecessary(){this.requestNormalizeDelta&&(this.requestNormalizeDelta=!1,normalizeDelta(this))}}function normalizeDelta(T){let node=T.root,delta=0;for(;node!==SENTINEL;)node.left===SENTINEL||getNodeIsVisited(node.left)?node.right===SENTINEL||getNodeIsVisited(node.right)?(node.start=delta+node.start,node.end=delta+node.end,node.delta=0,recomputeMaxEnd(node),setNodeIsVisited(node,!0),setNodeIsVisited(node.left,!1),setNodeIsVisited(node.right,!1),node===node.parent.right&&(delta-=node.parent.delta),node=node.parent):(delta+=node.delta,node=node.right):node=node.left;setNodeIsVisited(T.root,!1)}function adjustMarkerBeforeColumn(markerOffset,markerStickToPreviousCharacter,checkOffset,moveSemantics){return markerOffset<checkOffset||!(markerOffset>checkOffset)&&(1!==moveSemantics&&(2===moveSemantics||markerStickToPreviousCharacter))}export function nodeAcceptEdit(node,start,end,textLength,forceMoveMarkers){const nodeStickiness=getNodeStickiness(node),startStickToPreviousCharacter=0===nodeStickiness||2===nodeStickiness,endStickToPreviousCharacter=1===nodeStickiness||2===nodeStickiness,deletingCnt=end-start,insertingCnt=textLength,commonLength=Math.min(deletingCnt,insertingCnt),nodeStart=node.start;let startDone=!1;const nodeEnd=node.end;let endDone=!1;start<=nodeStart&&nodeEnd<=end&&getCollapseOnReplaceEdit(node)&&(node.start=start,startDone=!0,node.end=start,endDone=!0);{const moveSemantics=forceMoveMarkers?1:deletingCnt>0?2:0;!startDone&&adjustMarkerBeforeColumn(nodeStart,startStickToPreviousCharacter,start,moveSemantics)&&(startDone=!0),!endDone&&adjustMarkerBeforeColumn(nodeEnd,endStickToPreviousCharacter,start,moveSemantics)&&(endDone=!0)}if(commonLength>0&&!forceMoveMarkers){const moveSemantics=deletingCnt>insertingCnt?2:0;!startDone&&adjustMarkerBeforeColumn(nodeStart,startStickToPreviousCharacter,start+commonLength,moveSemantics)&&(startDone=!0),!endDone&&adjustMarkerBeforeColumn(nodeEnd,endStickToPreviousCharacter,start+commonLength,moveSemantics)&&(endDone=!0)}{const moveSemantics=forceMoveMarkers?1:0;!startDone&&adjustMarkerBeforeColumn(nodeStart,startStickToPreviousCharacter,end,moveSemantics)&&(node.start=start+insertingCnt,startDone=!0),!endDone&&adjustMarkerBeforeColumn(nodeEnd,endStickToPreviousCharacter,end,moveSemantics)&&(node.end=start+insertingCnt,endDone=!0)}const deltaColumn=insertingCnt-deletingCnt;startDone||(node.start=Math.max(0,nodeStart+deltaColumn)),endDone||(node.end=Math.max(0,nodeEnd+deltaColumn)),node.start>node.end&&(node.end=node.start)}function searchForEditing(T,start,end){let node=T.root,delta=0,nodeMaxEnd=0,nodeStart=0,nodeEnd=0;const result=[];let resultLen=0;for(;node!==SENTINEL;)if(getNodeIsVisited(node))setNodeIsVisited(node.left,!1),setNodeIsVisited(node.right,!1),node===node.parent.right&&(delta-=node.parent.delta),node=node.parent;else{if(!getNodeIsVisited(node.left)){if(nodeMaxEnd=delta+node.maxEnd,nodeMaxEnd<start){setNodeIsVisited(node,!0);continue}if(node.left!==SENTINEL){node=node.left;continue}}nodeStart=delta+node.start,nodeStart>end?setNodeIsVisited(node,!0):(nodeEnd=delta+node.end,nodeEnd>=start&&(node.setCachedOffsets(nodeStart,nodeEnd,0),result[resultLen++]=node),setNodeIsVisited(node,!0),node.right===SENTINEL||getNodeIsVisited(node.right)||(delta+=node.delta,node=node.right))}return setNodeIsVisited(T.root,!1),result}function noOverlapReplace(T,start,end,textLength){let node=T.root,delta=0,nodeMaxEnd=0,nodeStart=0;const editDelta=textLength-(end-start);for(;node!==SENTINEL;)if(getNodeIsVisited(node))setNodeIsVisited(node.left,!1),setNodeIsVisited(node.right,!1),node===node.parent.right&&(delta-=node.parent.delta),recomputeMaxEnd(node),node=node.parent;else{if(!getNodeIsVisited(node.left)){if(nodeMaxEnd=delta+node.maxEnd,nodeMaxEnd<start){setNodeIsVisited(node,!0);continue}if(node.left!==SENTINEL){node=node.left;continue}}nodeStart=delta+node.start,nodeStart>end?(node.start+=editDelta,node.end+=editDelta,node.delta+=editDelta,(node.delta<-1073741824||node.delta>1073741824)&&(T.requestNormalizeDelta=!0),setNodeIsVisited(node,!0)):(setNodeIsVisited(node,!0),node.right===SENTINEL||getNodeIsVisited(node.right)||(delta+=node.delta,node=node.right))}setNodeIsVisited(T.root,!1)}function collectNodesFromOwner(T,ownerId){let node=T.root;const result=[];let resultLen=0;for(;node!==SENTINEL;)getNodeIsVisited(node)?(setNodeIsVisited(node.left,!1),setNodeIsVisited(node.right,!1),node=node.parent):node.left===SENTINEL||getNodeIsVisited(node.left)?(node.ownerId===ownerId&&(result[resultLen++]=node),setNodeIsVisited(node,!0),node.right===SENTINEL||getNodeIsVisited(node.right)||(node=node.right)):node=node.left;return setNodeIsVisited(T.root,!1),result}function collectNodesPostOrder(T){let node=T.root;const result=[];let resultLen=0;for(;node!==SENTINEL;)getNodeIsVisited(node)?(setNodeIsVisited(node.left,!1),setNodeIsVisited(node.right,!1),node=node.parent):node.left===SENTINEL||getNodeIsVisited(node.left)?node.right===SENTINEL||getNodeIsVisited(node.right)?(result[resultLen++]=node,setNodeIsVisited(node,!0)):node=node.right:node=node.left;return setNodeIsVisited(T.root,!1),result}function search(T,filterOwnerId,filterOutValidation,cachedVersionId){let node=T.root,delta=0,nodeStart=0,nodeEnd=0;const result=[];let resultLen=0;for(;node!==SENTINEL;){if(getNodeIsVisited(node)){setNodeIsVisited(node.left,!1),setNodeIsVisited(node.right,!1),node===node.parent.right&&(delta-=node.parent.delta),node=node.parent;continue}if(node.left!==SENTINEL&&!getNodeIsVisited(node.left)){node=node.left;continue}nodeStart=delta+node.start,nodeEnd=delta+node.end,node.setCachedOffsets(nodeStart,nodeEnd,cachedVersionId);let include=!0;filterOwnerId&&node.ownerId&&node.ownerId!==filterOwnerId&&(include=!1),filterOutValidation&&getNodeIsForValidation(node)&&(include=!1),include&&(result[resultLen++]=node),setNodeIsVisited(node,!0),node.right===SENTINEL||getNodeIsVisited(node.right)||(delta+=node.delta,node=node.right)}return setNodeIsVisited(T.root,!1),result}function intervalSearch(T,intervalStart,intervalEnd,filterOwnerId,filterOutValidation,cachedVersionId){let node=T.root,delta=0,nodeMaxEnd=0,nodeStart=0,nodeEnd=0;const result=[];let resultLen=0;for(;node!==SENTINEL;)if(getNodeIsVisited(node))setNodeIsVisited(node.left,!1),setNodeIsVisited(node.right,!1),node===node.parent.right&&(delta-=node.parent.delta),node=node.parent;else{if(!getNodeIsVisited(node.left)){if(nodeMaxEnd=delta+node.maxEnd,nodeMaxEnd<intervalStart){setNodeIsVisited(node,!0);continue}if(node.left!==SENTINEL){node=node.left;continue}}if(nodeStart=delta+node.start,nodeStart>intervalEnd)setNodeIsVisited(node,!0);else{if(nodeEnd=delta+node.end,nodeEnd>=intervalStart){node.setCachedOffsets(nodeStart,nodeEnd,cachedVersionId);let include=!0;filterOwnerId&&node.ownerId&&node.ownerId!==filterOwnerId&&(include=!1),filterOutValidation&&getNodeIsForValidation(node)&&(include=!1),include&&(result[resultLen++]=node)}setNodeIsVisited(node,!0),node.right===SENTINEL||getNodeIsVisited(node.right)||(delta+=node.delta,node=node.right)}}return setNodeIsVisited(T.root,!1),result}function rbTreeInsert(T,newNode){if(T.root===SENTINEL)return newNode.parent=SENTINEL,newNode.left=SENTINEL,newNode.right=SENTINEL,setNodeColor(newNode,0),T.root=newNode,T.root;treeInsert(T,newNode),recomputeMaxEndWalkToRoot(newNode.parent);let x=newNode;for(;x!==T.root&&1===getNodeColor(x.parent);)if(x.parent===x.parent.parent.left){const y=x.parent.parent.right;1===getNodeColor(y)?(setNodeColor(x.parent,0),setNodeColor(y,0),setNodeColor(x.parent.parent,1),x=x.parent.parent):(x===x.parent.right&&(x=x.parent,leftRotate(T,x)),setNodeColor(x.parent,0),setNodeColor(x.parent.parent,1),rightRotate(T,x.parent.parent))}else{const y=x.parent.parent.left;1===getNodeColor(y)?(setNodeColor(x.parent,0),setNodeColor(y,0),setNodeColor(x.parent.parent,1),x=x.parent.parent):(x===x.parent.left&&(x=x.parent,rightRotate(T,x)),setNodeColor(x.parent,0),setNodeColor(x.parent.parent,1),leftRotate(T,x.parent.parent))}return setNodeColor(T.root,0),newNode}function treeInsert(T,z){let delta=0,x=T.root;const zAbsoluteStart=z.start,zAbsoluteEnd=z.end;for(;;){if(intervalCompare(zAbsoluteStart,zAbsoluteEnd,x.start+delta,x.end+delta)<0){if(x.left===SENTINEL){z.start-=delta,z.end-=delta,z.maxEnd-=delta,x.left=z;break}x=x.left}else{if(x.right===SENTINEL){z.start-=delta+x.delta,z.end-=delta+x.delta,z.maxEnd-=delta+x.delta,x.right=z;break}delta+=x.delta,x=x.right}}z.parent=x,z.left=SENTINEL,z.right=SENTINEL,setNodeColor(z,1)}function rbTreeDelete(T,z){let x,y;if(z.left===SENTINEL?(x=z.right,y=z,x.delta+=z.delta,(x.delta<-1073741824||x.delta>1073741824)&&(T.requestNormalizeDelta=!0),x.start+=z.delta,x.end+=z.delta):z.right===SENTINEL?(x=z.left,y=z):(y=leftest(z.right),x=y.right,x.start+=y.delta,x.end+=y.delta,x.delta+=y.delta,(x.delta<-1073741824||x.delta>1073741824)&&(T.requestNormalizeDelta=!0),y.start+=z.delta,y.end+=z.delta,y.delta=z.delta,(y.delta<-1073741824||y.delta>1073741824)&&(T.requestNormalizeDelta=!0)),y===T.root)return T.root=x,setNodeColor(x,0),z.detach(),resetSentinel(),recomputeMaxEnd(x),void(T.root.parent=SENTINEL);const yWasRed=1===getNodeColor(y);if(y===y.parent.left?y.parent.left=x:y.parent.right=x,y===z?x.parent=y.parent:(y.parent===z?x.parent=y:x.parent=y.parent,y.left=z.left,y.right=z.right,y.parent=z.parent,setNodeColor(y,getNodeColor(z)),z===T.root?T.root=y:z===z.parent.left?z.parent.left=y:z.parent.right=y,y.left!==SENTINEL&&(y.left.parent=y),y.right!==SENTINEL&&(y.right.parent=y)),z.detach(),yWasRed)return recomputeMaxEndWalkToRoot(x.parent),y!==z&&(recomputeMaxEndWalkToRoot(y),recomputeMaxEndWalkToRoot(y.parent)),void resetSentinel();let w;for(recomputeMaxEndWalkToRoot(x),recomputeMaxEndWalkToRoot(x.parent),y!==z&&(recomputeMaxEndWalkToRoot(y),recomputeMaxEndWalkToRoot(y.parent));x!==T.root&&0===getNodeColor(x);)x===x.parent.left?(w=x.parent.right,1===getNodeColor(w)&&(setNodeColor(w,0),setNodeColor(x.parent,1),leftRotate(T,x.parent),w=x.parent.right),0===getNodeColor(w.left)&&0===getNodeColor(w.right)?(setNodeColor(w,1),x=x.parent):(0===getNodeColor(w.right)&&(setNodeColor(w.left,0),setNodeColor(w,1),rightRotate(T,w),w=x.parent.right),setNodeColor(w,getNodeColor(x.parent)),setNodeColor(x.parent,0),setNodeColor(w.right,0),leftRotate(T,x.parent),x=T.root)):(w=x.parent.left,1===getNodeColor(w)&&(setNodeColor(w,0),setNodeColor(x.parent,1),rightRotate(T,x.parent),w=x.parent.left),0===getNodeColor(w.left)&&0===getNodeColor(w.right)?(setNodeColor(w,1),x=x.parent):(0===getNodeColor(w.left)&&(setNodeColor(w.right,0),setNodeColor(w,1),leftRotate(T,w),w=x.parent.left),setNodeColor(w,getNodeColor(x.parent)),setNodeColor(x.parent,0),setNodeColor(w.left,0),rightRotate(T,x.parent),x=T.root));setNodeColor(x,0),resetSentinel()}function leftest(node){for(;node.left!==SENTINEL;)node=node.left;return node}function resetSentinel(){SENTINEL.parent=SENTINEL,SENTINEL.delta=0,SENTINEL.start=0,SENTINEL.end=0}function leftRotate(T,x){const y=x.right;y.delta+=x.delta,(y.delta<-1073741824||y.delta>1073741824)&&(T.requestNormalizeDelta=!0),y.start+=x.delta,y.end+=x.delta,x.right=y.left,y.left!==SENTINEL&&(y.left.parent=x),y.parent=x.parent,x.parent===SENTINEL?T.root=y:x===x.parent.left?x.parent.left=y:x.parent.right=y,y.left=x,x.parent=y,recomputeMaxEnd(x),recomputeMaxEnd(y)}function rightRotate(T,y){const x=y.left;y.delta-=x.delta,(y.delta<-1073741824||y.delta>1073741824)&&(T.requestNormalizeDelta=!0),y.start-=x.delta,y.end-=x.delta,y.left=x.right,x.right!==SENTINEL&&(x.right.parent=y),x.parent=y.parent,y.parent===SENTINEL?T.root=x:y===y.parent.right?y.parent.right=x:y.parent.left=x,x.right=y,y.parent=x,recomputeMaxEnd(y),recomputeMaxEnd(x)}function computeMaxEnd(node){let maxEnd=node.end;if(node.left!==SENTINEL){const leftMaxEnd=node.left.maxEnd;leftMaxEnd>maxEnd&&(maxEnd=leftMaxEnd)}if(node.right!==SENTINEL){const rightMaxEnd=node.right.maxEnd+node.delta;rightMaxEnd>maxEnd&&(maxEnd=rightMaxEnd)}return maxEnd}export function recomputeMaxEnd(node){node.maxEnd=computeMaxEnd(node)}function recomputeMaxEndWalkToRoot(node){for(;node!==SENTINEL;){const maxEnd=computeMaxEnd(node);if(node.maxEnd===maxEnd)return;node.maxEnd=maxEnd,node=node.parent}}export function intervalCompare(aStart,aEnd,bStart,bEnd){return aStart===bStart?aEnd-bEnd:aStart-bStart}