import{onUnexpectedError}from"../../../base/common/errors.js";import*as strings from"../../../base/common/strings.js";import{ReplaceCommand,ReplaceCommandWithOffsetCursorState,ReplaceCommandWithoutChangingPosition,ReplaceCommandThatPreservesSelection}from"../commands/replaceCommand.js";import{ShiftCommand}from"../commands/shiftCommand.js";import{CompositionSurroundSelectionCommand,SurroundSelectionCommand}from"../commands/surroundSelectionCommand.js";import{EditOperationResult,isQuote}from"../cursorCommon.js";import{getMapForWordSeparators}from"../core/wordCharacterClassifier.js";import{Range}from"../core/range.js";import{Position}from"../core/position.js";import{IndentAction}from"../languages/languageConfiguration.js";import{getIndentationAtPosition}from"../languages/languageConfigurationRegistry.js";import{createScopedLineTokens}from"../languages/supports.js";import{getIndentActionForType,getIndentForEnter,getInheritIndentForLine}from"../languages/autoIndent.js";import{getEnterAction}from"../languages/enterAction.js";export class TypeOperations{static indent(config,model,selections){if(null===model||null===selections)return[];const commands=[];for(let i=0,len=selections.length;i<len;i++)commands[i]=new ShiftCommand(selections[i],{isUnshift:!1,tabSize:config.tabSize,indentSize:config.indentSize,insertSpaces:config.insertSpaces,useTabStops:config.useTabStops,autoIndent:config.autoIndent},config.languageConfigurationService);return commands}static outdent(config,model,selections){const commands=[];for(let i=0,len=selections.length;i<len;i++)commands[i]=new ShiftCommand(selections[i],{isUnshift:!0,tabSize:config.tabSize,indentSize:config.indentSize,insertSpaces:config.insertSpaces,useTabStops:config.useTabStops,autoIndent:config.autoIndent},config.languageConfigurationService);return commands}static shiftIndent(config,indentation,count){return count=count||1,ShiftCommand.shiftIndent(indentation,indentation.length+count,config.tabSize,config.indentSize,config.insertSpaces)}static unshiftIndent(config,indentation,count){return count=count||1,ShiftCommand.unshiftIndent(indentation,indentation.length+count,config.tabSize,config.indentSize,config.insertSpaces)}static _distributedPaste(config,model,selections,text){const commands=[];for(let i=0,len=selections.length;i<len;i++)commands[i]=new ReplaceCommand(selections[i],text[i]);return new EditOperationResult(0,commands,{shouldPushStackElementBefore:!0,shouldPushStackElementAfter:!0})}static _simplePaste(config,model,selections,text,pasteOnNewLine){const commands=[];for(let i=0,len=selections.length;i<len;i++){const selection=selections[i],position=selection.getPosition();if(pasteOnNewLine&&!selection.isEmpty()&&(pasteOnNewLine=!1),pasteOnNewLine&&text.indexOf("\n")!==text.length-1&&(pasteOnNewLine=!1),pasteOnNewLine){const typeSelection=new Range(position.lineNumber,1,position.lineNumber,1);commands[i]=new ReplaceCommandThatPreservesSelection(typeSelection,text,selection,!0)}else commands[i]=new ReplaceCommand(selection,text)}return new EditOperationResult(0,commands,{shouldPushStackElementBefore:!0,shouldPushStackElementAfter:!0})}static _distributePasteToCursors(config,selections,text,pasteOnNewLine,multicursorText){if(pasteOnNewLine)return null;if(1===selections.length)return null;if(multicursorText&&multicursorText.length===selections.length)return multicursorText;if("spread"===config.multiCursorPaste){10===text.charCodeAt(text.length-1)&&(text=text.substr(0,text.length-1)),13===text.charCodeAt(text.length-1)&&(text=text.substr(0,text.length-1));const lines=strings.splitLines(text);if(lines.length===selections.length)return lines}return null}static paste(config,model,selections,text,pasteOnNewLine,multicursorText){const distributedPaste=this._distributePasteToCursors(config,selections,text,pasteOnNewLine,multicursorText);return distributedPaste?(selections=selections.sort(Range.compareRangesUsingStarts),this._distributedPaste(config,model,selections,distributedPaste)):this._simplePaste(config,model,selections,text,pasteOnNewLine)}static _goodIndentForLine(config,model,lineNumber){let action=null,indentation="";const expectedIndentAction=getInheritIndentForLine(config.autoIndent,model,lineNumber,!1,config.languageConfigurationService);if(expectedIndentAction)action=expectedIndentAction.action,indentation=expectedIndentAction.indentation;else if(lineNumber>1){let lastLineNumber;for(lastLineNumber=lineNumber-1;lastLineNumber>=1;lastLineNumber--){const lineText=model.getLineContent(lastLineNumber);if(strings.lastNonWhitespaceIndex(lineText)>=0)break}if(lastLineNumber<1)return null;const maxColumn=model.getLineMaxColumn(lastLineNumber),expectedEnterAction=getEnterAction(config.autoIndent,model,new Range(lastLineNumber,maxColumn,lastLineNumber,maxColumn),config.languageConfigurationService);expectedEnterAction&&(indentation=expectedEnterAction.indentation+expectedEnterAction.appendText)}return action&&(action===IndentAction.Indent&&(indentation=TypeOperations.shiftIndent(config,indentation)),action===IndentAction.Outdent&&(indentation=TypeOperations.unshiftIndent(config,indentation)),indentation=config.normalizeIndentation(indentation)),indentation||null}static _replaceJumpToNextIndent(config,model,selection,insertsAutoWhitespace){let typeText="";const position=selection.getStartPosition();if(config.insertSpaces){const visibleColumnFromColumn=config.visibleColumnFromColumn(model,position),indentSize=config.indentSize,spacesCnt=indentSize-visibleColumnFromColumn%indentSize;for(let i=0;i<spacesCnt;i++)typeText+=" "}else typeText="\t";return new ReplaceCommand(selection,typeText,insertsAutoWhitespace)}static tab(config,model,selections){const commands=[];for(let i=0,len=selections.length;i<len;i++){const selection=selections[i];if(selection.isEmpty()){const lineText=model.getLineContent(selection.startLineNumber);if(/^\s*$/.test(lineText)&&model.tokenization.isCheapToTokenize(selection.startLineNumber)){let goodIndent=this._goodIndentForLine(config,model,selection.startLineNumber);goodIndent=goodIndent||"\t";const possibleTypeText=config.normalizeIndentation(goodIndent);if(!lineText.startsWith(possibleTypeText)){commands[i]=new ReplaceCommand(new Range(selection.startLineNumber,1,selection.startLineNumber,lineText.length+1),possibleTypeText,!0);continue}}commands[i]=this._replaceJumpToNextIndent(config,model,selection,!0)}else{if(selection.startLineNumber===selection.endLineNumber){const lineMaxColumn=model.getLineMaxColumn(selection.startLineNumber);if(1!==selection.startColumn||selection.endColumn!==lineMaxColumn){commands[i]=this._replaceJumpToNextIndent(config,model,selection,!1);continue}}commands[i]=new ShiftCommand(selection,{isUnshift:!1,tabSize:config.tabSize,indentSize:config.indentSize,insertSpaces:config.insertSpaces,useTabStops:config.useTabStops,autoIndent:config.autoIndent},config.languageConfigurationService)}}return commands}static compositionType(prevEditOperationType,config,model,selections,text,replacePrevCharCnt,replaceNextCharCnt,positionDelta){const commands=selections.map((selection=>this._compositionType(model,selection,text,replacePrevCharCnt,replaceNextCharCnt,positionDelta)));return new EditOperationResult(4,commands,{shouldPushStackElementBefore:shouldPushStackElementBetween(prevEditOperationType,4),shouldPushStackElementAfter:!1})}static _compositionType(model,selection,text,replacePrevCharCnt,replaceNextCharCnt,positionDelta){if(!selection.isEmpty())return null;const pos=selection.getPosition(),startColumn=Math.max(1,pos.column-replacePrevCharCnt),endColumn=Math.min(model.getLineMaxColumn(pos.lineNumber),pos.column+replaceNextCharCnt),range=new Range(pos.lineNumber,startColumn,pos.lineNumber,endColumn);return model.getValueInRange(range)===text&&0===positionDelta?null:new ReplaceCommandWithOffsetCursorState(range,text,0,positionDelta)}static _typeCommand(range,text,keepPosition){return keepPosition?new ReplaceCommandWithoutChangingPosition(range,text,!0):new ReplaceCommand(range,text,!0)}static _enter(config,model,keepPosition,range){if(0===config.autoIndent)return TypeOperations._typeCommand(range,"\n",keepPosition);if(!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber)||1===config.autoIndent){const lineText=model.getLineContent(range.startLineNumber),indentation=strings.getLeadingWhitespace(lineText).substring(0,range.startColumn-1);return TypeOperations._typeCommand(range,"\n"+config.normalizeIndentation(indentation),keepPosition)}const r=getEnterAction(config.autoIndent,model,range,config.languageConfigurationService);if(r){if(r.indentAction===IndentAction.None)return TypeOperations._typeCommand(range,"\n"+config.normalizeIndentation(r.indentation+r.appendText),keepPosition);if(r.indentAction===IndentAction.Indent)return TypeOperations._typeCommand(range,"\n"+config.normalizeIndentation(r.indentation+r.appendText),keepPosition);if(r.indentAction===IndentAction.IndentOutdent){const normalIndent=config.normalizeIndentation(r.indentation),increasedIndent=config.normalizeIndentation(r.indentation+r.appendText),typeText="\n"+increasedIndent+"\n"+normalIndent;return keepPosition?new ReplaceCommandWithoutChangingPosition(range,typeText,!0):new ReplaceCommandWithOffsetCursorState(range,typeText,-1,increasedIndent.length-normalIndent.length,!0)}if(r.indentAction===IndentAction.Outdent){const actualIndentation=TypeOperations.unshiftIndent(config,r.indentation);return TypeOperations._typeCommand(range,"\n"+config.normalizeIndentation(actualIndentation+r.appendText),keepPosition)}}const lineText=model.getLineContent(range.startLineNumber),indentation=strings.getLeadingWhitespace(lineText).substring(0,range.startColumn-1);if(config.autoIndent>=4){const ir=getIndentForEnter(config.autoIndent,model,range,{unshiftIndent:indent=>TypeOperations.unshiftIndent(config,indent),shiftIndent:indent=>TypeOperations.shiftIndent(config,indent),normalizeIndentation:indent=>config.normalizeIndentation(indent)},config.languageConfigurationService);if(ir){let oldEndViewColumn=config.visibleColumnFromColumn(model,range.getEndPosition());const oldEndColumn=range.endColumn,newLineContent=model.getLineContent(range.endLineNumber),firstNonWhitespace=strings.firstNonWhitespaceIndex(newLineContent);if(range=firstNonWhitespace>=0?range.setEndPosition(range.endLineNumber,Math.max(range.endColumn,firstNonWhitespace+1)):range.setEndPosition(range.endLineNumber,model.getLineMaxColumn(range.endLineNumber)),keepPosition)return new ReplaceCommandWithoutChangingPosition(range,"\n"+config.normalizeIndentation(ir.afterEnter),!0);{let offset=0;return oldEndColumn<=firstNonWhitespace+1&&(config.insertSpaces||(oldEndViewColumn=Math.ceil(oldEndViewColumn/config.indentSize)),offset=Math.min(oldEndViewColumn+1-config.normalizeIndentation(ir.afterEnter).length-1,0)),new ReplaceCommandWithOffsetCursorState(range,"\n"+config.normalizeIndentation(ir.afterEnter),0,offset,!0)}}}return TypeOperations._typeCommand(range,"\n"+config.normalizeIndentation(indentation),keepPosition)}static _isAutoIndentType(config,model,selections){if(config.autoIndent<4)return!1;for(let i=0,len=selections.length;i<len;i++)if(!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber))return!1;return!0}static _runAutoIndentType(config,model,range,ch){const currentIndentation=getIndentationAtPosition(model,range.startLineNumber,range.startColumn),actualIndentation=getIndentActionForType(config.autoIndent,model,range,ch,{shiftIndent:indentation=>TypeOperations.shiftIndent(config,indentation),unshiftIndent:indentation=>TypeOperations.unshiftIndent(config,indentation)},config.languageConfigurationService);if(null===actualIndentation)return null;if(actualIndentation!==config.normalizeIndentation(currentIndentation)){const firstNonWhitespace=model.getLineFirstNonWhitespaceColumn(range.startLineNumber);return 0===firstNonWhitespace?TypeOperations._typeCommand(new Range(range.startLineNumber,1,range.endLineNumber,range.endColumn),config.normalizeIndentation(actualIndentation)+ch,!1):TypeOperations._typeCommand(new Range(range.startLineNumber,1,range.endLineNumber,range.endColumn),config.normalizeIndentation(actualIndentation)+model.getLineContent(range.startLineNumber).substring(firstNonWhitespace-1,range.startColumn-1)+ch,!1)}return null}static _isAutoClosingOvertype(config,model,selections,autoClosedCharacters,ch){if("never"===config.autoClosingOvertype)return!1;if(!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch))return!1;for(let i=0,len=selections.length;i<len;i++){const selection=selections[i];if(!selection.isEmpty())return!1;const position=selection.getPosition(),lineText=model.getLineContent(position.lineNumber);if(lineText.charAt(position.column-1)!==ch)return!1;const chIsQuote=isQuote(ch);if(92===(position.column>2?lineText.charCodeAt(position.column-2):0)&&chIsQuote)return!1;if("auto"===config.autoClosingOvertype){let found=!1;for(let j=0,lenJ=autoClosedCharacters.length;j<lenJ;j++){const autoClosedCharacter=autoClosedCharacters[j];if(position.lineNumber===autoClosedCharacter.startLineNumber&&position.column===autoClosedCharacter.startColumn){found=!0;break}}if(!found)return!1}}return!0}static _runAutoClosingOvertype(prevEditOperationType,config,model,selections,ch){const commands=[];for(let i=0,len=selections.length;i<len;i++){const position=selections[i].getPosition(),typeSelection=new Range(position.lineNumber,position.column,position.lineNumber,position.column+1);commands[i]=new ReplaceCommand(typeSelection,ch)}return new EditOperationResult(4,commands,{shouldPushStackElementBefore:shouldPushStackElementBetween(prevEditOperationType,4),shouldPushStackElementAfter:!1})}static _isBeforeClosingBrace(config,lineAfter){const nextChar=lineAfter.charAt(0),potentialStartingBraces=config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar)||[],potentialClosingBraces=config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar)||[],isBeforeStartingBrace=potentialStartingBraces.some((x=>lineAfter.startsWith(x.open))),isBeforeClosingBrace=potentialClosingBraces.some((x=>lineAfter.startsWith(x.close)));return!isBeforeStartingBrace&&isBeforeClosingBrace}static _findAutoClosingPairOpen(config,model,positions,ch){const candidates=config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);if(!candidates)return null;let result=null;for(const candidate of candidates)if(null===result||candidate.open.length>result.open.length){let candidateIsMatch=!0;for(const position of positions){if(model.getValueInRange(new Range(position.lineNumber,position.column-candidate.open.length+1,position.lineNumber,position.column))+ch!==candidate.open){candidateIsMatch=!1;break}}candidateIsMatch&&(result=candidate)}return result}static _findContainedAutoClosingPair(config,pair){if(pair.open.length<=1)return null;const lastChar=pair.close.charAt(pair.close.length-1),candidates=config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar)||[];let result=null;for(const candidate of candidates)candidate.open!==pair.open&&pair.open.includes(candidate.open)&&pair.close.endsWith(candidate.close)&&(!result||candidate.open.length>result.open.length)&&(result=candidate);return result}static _getAutoClosingPairClose(config,model,selections,ch,chIsAlreadyTyped){const chIsQuote=isQuote(ch),autoCloseConfig=chIsQuote?config.autoClosingQuotes:config.autoClosingBrackets,shouldAutoCloseBefore=chIsQuote?config.shouldAutoCloseBefore.quote:config.shouldAutoCloseBefore.bracket;if("never"===autoCloseConfig)return null;for(const selection of selections)if(!selection.isEmpty())return null;const positions=selections.map((s=>{const position=s.getPosition();return chIsAlreadyTyped?{lineNumber:position.lineNumber,beforeColumn:position.column-ch.length,afterColumn:position.column}:{lineNumber:position.lineNumber,beforeColumn:position.column,afterColumn:position.column}})),pair=this._findAutoClosingPairOpen(config,model,positions.map((p=>new Position(p.lineNumber,p.beforeColumn))),ch);if(!pair)return null;const containedPair=this._findContainedAutoClosingPair(config,pair),containedPairClose=containedPair?containedPair.close:"";let isContainedPairPresent=!0;for(const position of positions){const{lineNumber,beforeColumn,afterColumn}=position,lineText=model.getLineContent(lineNumber),lineBefore=lineText.substring(0,beforeColumn-1),lineAfter=lineText.substring(afterColumn-1);if(lineAfter.startsWith(containedPairClose)||(isContainedPairPresent=!1),lineAfter.length>0){const characterAfter=lineAfter.charAt(0);if(!TypeOperations._isBeforeClosingBrace(config,lineAfter)&&!shouldAutoCloseBefore(characterAfter))return null}if(1===pair.open.length&&("'"===ch||'"'===ch)&&"always"!==autoCloseConfig){const wordSeparators=getMapForWordSeparators(config.wordSeparators);if(lineBefore.length>0){const characterBefore=lineBefore.charCodeAt(lineBefore.length-1);if(0===wordSeparators.get(characterBefore))return null}}if(!model.tokenization.isCheapToTokenize(lineNumber))return null;model.tokenization.forceTokenization(lineNumber);const lineTokens=model.tokenization.getLineTokens(lineNumber),scopedLineTokens=createScopedLineTokens(lineTokens,beforeColumn-1);if(!pair.shouldAutoClose(scopedLineTokens,beforeColumn-scopedLineTokens.firstCharOffset))return null;const neutralCharacter=pair.findNeutralCharacter();if(neutralCharacter){const tokenType=model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber,beforeColumn,neutralCharacter);if(!pair.isOK(tokenType))return null}}return isContainedPairPresent?pair.close.substring(0,pair.close.length-containedPairClose.length):pair.close}static _runAutoClosingOpenCharType(prevEditOperationType,config,model,selections,ch,chIsAlreadyTyped,autoClosingPairClose){const commands=[];for(let i=0,len=selections.length;i<len;i++){const selection=selections[i];commands[i]=new TypeWithAutoClosingCommand(selection,ch,!chIsAlreadyTyped,autoClosingPairClose)}return new EditOperationResult(4,commands,{shouldPushStackElementBefore:!0,shouldPushStackElementAfter:!1})}static _shouldSurroundChar(config,ch){return isQuote(ch)?"quotes"===config.autoSurround||"languageDefined"===config.autoSurround:"brackets"===config.autoSurround||"languageDefined"===config.autoSurround}static _isSurroundSelectionType(config,model,selections,ch){if(!TypeOperations._shouldSurroundChar(config,ch)||!config.surroundingPairs.hasOwnProperty(ch))return!1;const isTypingAQuoteCharacter=isQuote(ch);for(const selection of selections){if(selection.isEmpty())return!1;let selectionContainsOnlyWhitespace=!0;for(let lineNumber=selection.startLineNumber;lineNumber<=selection.endLineNumber;lineNumber++){const lineText=model.getLineContent(lineNumber),startIndex=lineNumber===selection.startLineNumber?selection.startColumn-1:0,endIndex=lineNumber===selection.endLineNumber?selection.endColumn-1:lineText.length,selectedText=lineText.substring(startIndex,endIndex);if(/[^ \t]/.test(selectedText)){selectionContainsOnlyWhitespace=!1;break}}if(selectionContainsOnlyWhitespace)return!1;if(isTypingAQuoteCharacter&&selection.startLineNumber===selection.endLineNumber&&selection.startColumn+1===selection.endColumn){const selectionText=model.getValueInRange(selection);if(isQuote(selectionText))return!1}}return!0}static _runSurroundSelectionType(prevEditOperationType,config,model,selections,ch){const commands=[];for(let i=0,len=selections.length;i<len;i++){const selection=selections[i],closeCharacter=config.surroundingPairs[ch];commands[i]=new SurroundSelectionCommand(selection,ch,closeCharacter)}return new EditOperationResult(0,commands,{shouldPushStackElementBefore:!0,shouldPushStackElementAfter:!0})}static _isTypeInterceptorElectricChar(config,model,selections){return!(1!==selections.length||!model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber))}static _typeInterceptorElectricChar(prevEditOperationType,config,model,selection,ch){if(!config.electricChars.hasOwnProperty(ch)||!selection.isEmpty())return null;const position=selection.getPosition();model.tokenization.forceTokenization(position.lineNumber);const lineTokens=model.tokenization.getLineTokens(position.lineNumber);let electricAction;try{electricAction=config.onElectricCharacter(ch,lineTokens,position.column)}catch(e){return onUnexpectedError(e),null}if(!electricAction)return null;if(electricAction.matchOpenBracket){const endColumn=(lineTokens.getLineContent()+ch).lastIndexOf(electricAction.matchOpenBracket)+1,match=model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket,{lineNumber:position.lineNumber,column:endColumn},500);if(match){if(match.startLineNumber===position.lineNumber)return null;const matchLine=model.getLineContent(match.startLineNumber),matchLineIndentation=strings.getLeadingWhitespace(matchLine),newIndentation=config.normalizeIndentation(matchLineIndentation),lineText=model.getLineContent(position.lineNumber),lineFirstNonBlankColumn=model.getLineFirstNonWhitespaceColumn(position.lineNumber)||position.column,typeText=newIndentation+lineText.substring(lineFirstNonBlankColumn-1,position.column-1)+ch,typeSelection=new Range(position.lineNumber,1,position.lineNumber,position.column),command=new ReplaceCommand(typeSelection,typeText);return new EditOperationResult(getTypingOperation(typeText,prevEditOperationType),[command],{shouldPushStackElementBefore:!1,shouldPushStackElementAfter:!0})}}return null}static compositionEndWithInterceptors(prevEditOperationType,config,model,compositions,selections,autoClosedCharacters){if(!compositions)return null;let insertedText=null;for(const composition of compositions)if(null===insertedText)insertedText=composition.insertedText;else if(insertedText!==composition.insertedText)return null;if(!insertedText||1!==insertedText.length)return null;const ch=insertedText;let hasDeletion=!1;for(const composition of compositions)if(0!==composition.deletedText.length){hasDeletion=!0;break}if(hasDeletion){if(!TypeOperations._shouldSurroundChar(config,ch)||!config.surroundingPairs.hasOwnProperty(ch))return null;const isTypingAQuoteCharacter=isQuote(ch);for(const composition of compositions){if(0!==composition.deletedSelectionStart||composition.deletedSelectionEnd!==composition.deletedText.length)return null;if(/^[ \t]+$/.test(composition.deletedText))return null;if(isTypingAQuoteCharacter&&isQuote(composition.deletedText))return null}const positions=[];for(const selection of selections){if(!selection.isEmpty())return null;positions.push(selection.getPosition())}if(positions.length!==compositions.length)return null;const commands=[];for(let i=0,len=positions.length;i<len;i++)commands.push(new CompositionSurroundSelectionCommand(positions[i],compositions[i].deletedText,ch));return new EditOperationResult(4,commands,{shouldPushStackElementBefore:!0,shouldPushStackElementAfter:!1})}if(this._isAutoClosingOvertype(config,model,selections,autoClosedCharacters,ch)){const commands=selections.map((s=>new ReplaceCommand(new Range(s.positionLineNumber,s.positionColumn,s.positionLineNumber,s.positionColumn+1),"",!1)));return new EditOperationResult(4,commands,{shouldPushStackElementBefore:!0,shouldPushStackElementAfter:!1})}const autoClosingPairClose=this._getAutoClosingPairClose(config,model,selections,ch,!0);return null!==autoClosingPairClose?this._runAutoClosingOpenCharType(prevEditOperationType,config,model,selections,ch,!0,autoClosingPairClose):null}static typeWithInterceptors(isDoingComposition,prevEditOperationType,config,model,selections,autoClosedCharacters,ch){if(!isDoingComposition&&"\n"===ch){const commands=[];for(let i=0,len=selections.length;i<len;i++)commands[i]=TypeOperations._enter(config,model,!1,selections[i]);return new EditOperationResult(4,commands,{shouldPushStackElementBefore:!0,shouldPushStackElementAfter:!1})}if(!isDoingComposition&&this._isAutoIndentType(config,model,selections)){const commands=[];let autoIndentFails=!1;for(let i=0,len=selections.length;i<len;i++)if(commands[i]=this._runAutoIndentType(config,model,selections[i],ch),!commands[i]){autoIndentFails=!0;break}if(!autoIndentFails)return new EditOperationResult(4,commands,{shouldPushStackElementBefore:!0,shouldPushStackElementAfter:!1})}if(this._isAutoClosingOvertype(config,model,selections,autoClosedCharacters,ch))return this._runAutoClosingOvertype(prevEditOperationType,config,model,selections,ch);if(!isDoingComposition){const autoClosingPairClose=this._getAutoClosingPairClose(config,model,selections,ch,!1);if(autoClosingPairClose)return this._runAutoClosingOpenCharType(prevEditOperationType,config,model,selections,ch,!1,autoClosingPairClose)}if(!isDoingComposition&&this._isSurroundSelectionType(config,model,selections,ch))return this._runSurroundSelectionType(prevEditOperationType,config,model,selections,ch);if(!isDoingComposition&&this._isTypeInterceptorElectricChar(config,model,selections)){const r=this._typeInterceptorElectricChar(prevEditOperationType,config,model,selections[0],ch);if(r)return r}const commands=[];for(let i=0,len=selections.length;i<len;i++)commands[i]=new ReplaceCommand(selections[i],ch);const opType=getTypingOperation(ch,prevEditOperationType);return new EditOperationResult(opType,commands,{shouldPushStackElementBefore:shouldPushStackElementBetween(prevEditOperationType,opType),shouldPushStackElementAfter:!1})}static typeWithoutInterceptors(prevEditOperationType,config,model,selections,str){const commands=[];for(let i=0,len=selections.length;i<len;i++)commands[i]=new ReplaceCommand(selections[i],str);const opType=getTypingOperation(str,prevEditOperationType);return new EditOperationResult(opType,commands,{shouldPushStackElementBefore:shouldPushStackElementBetween(prevEditOperationType,opType),shouldPushStackElementAfter:!1})}static lineInsertBefore(config,model,selections){if(null===model||null===selections)return[];const commands=[];for(let i=0,len=selections.length;i<len;i++){let lineNumber=selections[i].positionLineNumber;if(1===lineNumber)commands[i]=new ReplaceCommandWithoutChangingPosition(new Range(1,1,1,1),"\n");else{lineNumber--;const column=model.getLineMaxColumn(lineNumber);commands[i]=this._enter(config,model,!1,new Range(lineNumber,column,lineNumber,column))}}return commands}static lineInsertAfter(config,model,selections){if(null===model||null===selections)return[];const commands=[];for(let i=0,len=selections.length;i<len;i++){const lineNumber=selections[i].positionLineNumber,column=model.getLineMaxColumn(lineNumber);commands[i]=this._enter(config,model,!1,new Range(lineNumber,column,lineNumber,column))}return commands}static lineBreakInsert(config,model,selections){const commands=[];for(let i=0,len=selections.length;i<len;i++)commands[i]=this._enter(config,model,!0,selections[i]);return commands}}export class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState{constructor(selection,openCharacter,insertOpenCharacter,closeCharacter){super(selection,(insertOpenCharacter?openCharacter:"")+closeCharacter,0,-closeCharacter.length),this._openCharacter=openCharacter,this._closeCharacter=closeCharacter,this.closeCharacterRange=null,this.enclosingRange=null}computeCursorState(model,helper){const range=helper.getInverseEditOperations()[0].range;return this.closeCharacterRange=new Range(range.startLineNumber,range.endColumn-this._closeCharacter.length,range.endLineNumber,range.endColumn),this.enclosingRange=new Range(range.startLineNumber,range.endColumn-this._openCharacter.length-this._closeCharacter.length,range.endLineNumber,range.endColumn),super.computeCursorState(model,helper)}}export class CompositionOutcome{constructor(deletedText,deletedSelectionStart,deletedSelectionEnd,insertedText,insertedSelectionStart,insertedSelectionEnd){this.deletedText=deletedText,this.deletedSelectionStart=deletedSelectionStart,this.deletedSelectionEnd=deletedSelectionEnd,this.insertedText=insertedText,this.insertedSelectionStart=insertedSelectionStart,this.insertedSelectionEnd=insertedSelectionEnd}}function getTypingOperation(typedText,previousTypingOperation){return" "===typedText?5===previousTypingOperation||6===previousTypingOperation?6:5:4}function shouldPushStackElementBetween(previousTypingOperation,typingOperation){return!(!isTypingOperation(previousTypingOperation)||isTypingOperation(typingOperation))||5!==previousTypingOperation&&normalizeOperationType(previousTypingOperation)!==normalizeOperationType(typingOperation)}function normalizeOperationType(type){return 6===type||5===type?"space":type}function isTypingOperation(type){return 4===type||5===type||6===type}