import{once}from"./functional.js";import{Iterable}from"./iterator.js";const TRACK_DISPOSABLES=!1;let disposableTracker=null;export function setDisposableTracker(tracker){disposableTracker=tracker}function trackDisposable(x){return null==disposableTracker||disposableTracker.trackDisposable(x),x}function markAsDisposed(disposable){null==disposableTracker||disposableTracker.markAsDisposed(disposable)}function setParentOfDisposable(child,parent){null==disposableTracker||disposableTracker.setParent(child,parent)}function setParentOfDisposables(children,parent){if(disposableTracker)for(const child of children)disposableTracker.setParent(child,parent)}export function markAsSingleton(singleton){return null==disposableTracker||disposableTracker.markAsSingleton(singleton),singleton}export class MultiDisposeError extends Error{constructor(errors){super(`Encountered errors while disposing of store. Errors: [${errors.join(", ")}]`),this.errors=errors}}export function isDisposable(thing){return"function"==typeof thing.dispose&&0===thing.dispose.length}export function dispose(arg){if(Iterable.is(arg)){const errors=[];for(const d of arg)if(d)try{d.dispose()}catch(e){errors.push(e)}if(1===errors.length)throw errors[0];if(errors.length>1)throw new MultiDisposeError(errors);return Array.isArray(arg)?[]:arg}if(arg)return arg.dispose(),arg}export function combinedDisposable(...disposables){const parent=toDisposable((()=>dispose(disposables)));return setParentOfDisposables(disposables,parent),parent}export function toDisposable(fn){const self=trackDisposable({dispose:once((()=>{markAsDisposed(self),fn()}))});return self}export class DisposableStore{constructor(){this._toDispose=new Set,this._isDisposed=!1,trackDisposable(this)}dispose(){this._isDisposed||(markAsDisposed(this),this._isDisposed=!0,this.clear())}get isDisposed(){return this._isDisposed}clear(){try{dispose(this._toDispose.values())}finally{this._toDispose.clear()}}add(o){if(!o)return o;if(o===this)throw new Error("Cannot register a disposable on itself!");return setParentOfDisposable(o,this),this._isDisposed?DisposableStore.DISABLE_DISPOSED_WARNING||console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack):this._toDispose.add(o),o}}DisposableStore.DISABLE_DISPOSED_WARNING=!1;export class Disposable{constructor(){this._store=new DisposableStore,trackDisposable(this),setParentOfDisposable(this._store,this)}dispose(){markAsDisposed(this),this._store.dispose()}_register(o){if(o===this)throw new Error("Cannot register a disposable on itself!");return this._store.add(o)}}Disposable.None=Object.freeze({dispose(){}});export class MutableDisposable{constructor(){this._isDisposed=!1,trackDisposable(this)}get value(){return this._isDisposed?void 0:this._value}set value(value){var _a;this._isDisposed||value===this._value||(null===(_a=this._value)||void 0===_a||_a.dispose(),value&&setParentOfDisposable(value,this),this._value=value)}clear(){this.value=void 0}dispose(){var _a;this._isDisposed=!0,markAsDisposed(this),null===(_a=this._value)||void 0===_a||_a.dispose(),this._value=void 0}clearAndLeak(){const oldValue=this._value;return this._value=void 0,oldValue&&setParentOfDisposable(oldValue,null),oldValue}}export class RefCountedDisposable{constructor(_disposable){this._disposable=_disposable,this._counter=1}acquire(){return this._counter++,this}release(){return 0==--this._counter&&this._disposable.dispose(),this}}export class SafeDisposable{constructor(){this.dispose=()=>{},this.unset=()=>{},this.isset=()=>!1,trackDisposable(this)}set(fn){let callback=fn;return this.unset=()=>callback=void 0,this.isset=()=>void 0!==callback,this.dispose=()=>{callback&&(callback(),callback=void 0,markAsDisposed(this))},this}}export class ImmortalReference{constructor(object){this.object=object}dispose(){}}