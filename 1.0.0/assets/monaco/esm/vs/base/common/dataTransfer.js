var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):function adopt(value){return value instanceof P?value:new P((function(resolve){resolve(value)}))}(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))};export function createStringDataTransferItem(stringOrPromise){return{asString:()=>__awaiter(this,void 0,void 0,(function*(){return stringOrPromise})),asFile:()=>{},value:"string"==typeof stringOrPromise?stringOrPromise:void 0}}export function createFileDataTransferItem(fileName,uri,data){return{asString:()=>__awaiter(this,void 0,void 0,(function*(){return""})),asFile:()=>({name:fileName,uri,data}),value:void 0}}export class VSDataTransfer{constructor(){this._entries=new Map}get size(){return this._entries.size}has(mimeType){return this._entries.has(this.toKey(mimeType))}get(mimeType){var _a;return null===(_a=this._entries.get(this.toKey(mimeType)))||void 0===_a?void 0:_a[0]}append(mimeType,value){const existing=this._entries.get(mimeType);existing?existing.push(value):this._entries.set(this.toKey(mimeType),[value])}replace(mimeType,value){this._entries.set(this.toKey(mimeType),[value])}delete(mimeType){this._entries.delete(this.toKey(mimeType))}*entries(){for(const[mine,items]of this._entries.entries())for(const item of items)yield[mine,item]}values(){return Array.from(this._entries.values()).flat()}forEach(f){for(const[mime,item]of this.entries())f(item,mime)}toKey(mimeType){return mimeType.toLowerCase()}}