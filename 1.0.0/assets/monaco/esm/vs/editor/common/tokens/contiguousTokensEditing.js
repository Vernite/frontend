import{LineTokens}from"./lineTokens.js";export const EMPTY_LINE_TOKENS=new Uint32Array(0).buffer;export class ContiguousTokensEditing{static deleteBeginning(lineTokens,toChIndex){return null===lineTokens||lineTokens===EMPTY_LINE_TOKENS?lineTokens:ContiguousTokensEditing.delete(lineTokens,0,toChIndex)}static deleteEnding(lineTokens,fromChIndex){if(null===lineTokens||lineTokens===EMPTY_LINE_TOKENS)return lineTokens;const tokens=toUint32Array(lineTokens),lineTextLength=tokens[tokens.length-2];return ContiguousTokensEditing.delete(lineTokens,fromChIndex,lineTextLength)}static delete(lineTokens,fromChIndex,toChIndex){if(null===lineTokens||lineTokens===EMPTY_LINE_TOKENS||fromChIndex===toChIndex)return lineTokens;const tokens=toUint32Array(lineTokens),tokensCount=tokens.length>>>1;if(0===fromChIndex&&tokens[tokens.length-2]===toChIndex)return EMPTY_LINE_TOKENS;const fromTokenIndex=LineTokens.findIndexInTokensArray(tokens,fromChIndex),fromTokenStartOffset=fromTokenIndex>0?tokens[fromTokenIndex-1<<1]:0;if(toChIndex<tokens[fromTokenIndex<<1]){const delta=toChIndex-fromChIndex;for(let i=fromTokenIndex;i<tokensCount;i++)tokens[i<<1]-=delta;return lineTokens}let dest,lastEnd;fromTokenStartOffset!==fromChIndex?(tokens[fromTokenIndex<<1]=fromChIndex,dest=fromTokenIndex+1<<1,lastEnd=fromChIndex):(dest=fromTokenIndex<<1,lastEnd=fromTokenStartOffset);const delta=toChIndex-fromChIndex;for(let tokenIndex=fromTokenIndex+1;tokenIndex<tokensCount;tokenIndex++){const tokenEndOffset=tokens[tokenIndex<<1]-delta;tokenEndOffset>lastEnd&&(tokens[dest++]=tokenEndOffset,tokens[dest++]=tokens[1+(tokenIndex<<1)],lastEnd=tokenEndOffset)}if(dest===tokens.length)return lineTokens;const tmp=new Uint32Array(dest);return tmp.set(tokens.subarray(0,dest),0),tmp.buffer}static append(lineTokens,_otherTokens){if(_otherTokens===EMPTY_LINE_TOKENS)return lineTokens;if(lineTokens===EMPTY_LINE_TOKENS)return _otherTokens;if(null===lineTokens)return lineTokens;if(null===_otherTokens)return null;const myTokens=toUint32Array(lineTokens),otherTokens=toUint32Array(_otherTokens),otherTokensCount=otherTokens.length>>>1,result=new Uint32Array(myTokens.length+otherTokens.length);result.set(myTokens,0);let dest=myTokens.length;const delta=myTokens[myTokens.length-2];for(let i=0;i<otherTokensCount;i++)result[dest++]=otherTokens[i<<1]+delta,result[dest++]=otherTokens[1+(i<<1)];return result.buffer}static insert(lineTokens,chIndex,textLength){if(null===lineTokens||lineTokens===EMPTY_LINE_TOKENS)return lineTokens;const tokens=toUint32Array(lineTokens),tokensCount=tokens.length>>>1;let fromTokenIndex=LineTokens.findIndexInTokensArray(tokens,chIndex);if(fromTokenIndex>0){tokens[fromTokenIndex-1<<1]===chIndex&&fromTokenIndex--}for(let tokenIndex=fromTokenIndex;tokenIndex<tokensCount;tokenIndex++)tokens[tokenIndex<<1]+=textLength;return lineTokens}}export function toUint32Array(arr){return arr instanceof Uint32Array?arr:new Uint32Array(arr)}