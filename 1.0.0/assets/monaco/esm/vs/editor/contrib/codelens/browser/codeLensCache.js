var __decorate=this&&this.__decorate||function(decorators,target,key,desc){var d,c=arguments.length,r=c<3?target:null===desc?desc=Object.getOwnPropertyDescriptor(target,key):desc;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(decorators,target,key,desc);else for(var i=decorators.length-1;i>=0;i--)(d=decorators[i])&&(r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r);return c>3&&r&&Object.defineProperty(target,key,r),r},__param=this&&this.__param||function(paramIndex,decorator){return function(target,key){decorator(target,key,paramIndex)}};import{runWhenIdle}from"../../../../base/common/async.js";import{once}from"../../../../base/common/functional.js";import{LRUCache}from"../../../../base/common/map.js";import{Range}from"../../../common/core/range.js";import{CodeLensModel}from"./codelens.js";import{registerSingleton}from"../../../../platform/instantiation/common/extensions.js";import{createDecorator}from"../../../../platform/instantiation/common/instantiation.js";import{IStorageService,WillSaveStateReason}from"../../../../platform/storage/common/storage.js";export const ICodeLensCache=createDecorator("ICodeLensCache");class CacheItem{constructor(lineCount,data){this.lineCount=lineCount,this.data=data}}let CodeLensCache=class CodeLensCache{constructor(storageService){this._fakeProvider=new class{provideCodeLenses(){throw new Error("not supported")}},this._cache=new LRUCache(20,.75);runWhenIdle((()=>storageService.remove("codelens/cache",1)));const key="codelens/cache2",raw=storageService.get(key,1,"{}");this._deserialize(raw),once(storageService.onWillSaveState)((e=>{e.reason===WillSaveStateReason.SHUTDOWN&&storageService.store(key,this._serialize(),1,1)}))}put(model,data){const copyItems=data.lenses.map((item=>{var _a;return{range:item.symbol.range,command:item.symbol.command&&{id:"",title:null===(_a=item.symbol.command)||void 0===_a?void 0:_a.title}}})),copyModel=new CodeLensModel;copyModel.add({lenses:copyItems,dispose:()=>{}},this._fakeProvider);const item=new CacheItem(model.getLineCount(),copyModel);this._cache.set(model.uri.toString(),item)}get(model){const item=this._cache.get(model.uri.toString());return item&&item.lineCount===model.getLineCount()?item.data:void 0}delete(model){this._cache.delete(model.uri.toString())}_serialize(){const data=Object.create(null);for(const[key,value]of this._cache){const lines=new Set;for(const d of value.data.lenses)lines.add(d.symbol.range.startLineNumber);data[key]={lineCount:value.lineCount,lines:[...lines.values()]}}return JSON.stringify(data)}_deserialize(raw){try{const data=JSON.parse(raw);for(const key in data){const element=data[key],lenses=[];for(const line of element.lines)lenses.push({range:new Range(line,1,line,11)});const model=new CodeLensModel;model.add({lenses,dispose(){}},this._fakeProvider),this._cache.set(key,new CacheItem(element.lineCount,model))}}catch(_a){}}};CodeLensCache=__decorate([__param(0,IStorageService)],CodeLensCache);export{CodeLensCache};registerSingleton(ICodeLensCache,CodeLensCache);