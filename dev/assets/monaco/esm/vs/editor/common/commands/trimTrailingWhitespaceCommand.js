import*as strings from"../../../base/common/strings.js";import{EditOperation}from"../core/editOperation.js";import{Range}from"../core/range.js";export class TrimTrailingWhitespaceCommand{constructor(selection,cursors){this._selection=selection,this._cursors=cursors,this._selectionId=null}getEditOperations(model,builder){const ops=trimTrailingWhitespace(model,this._cursors);for(let i=0,len=ops.length;i<len;i++){const op=ops[i];builder.addEditOperation(op.range,op.text)}this._selectionId=builder.trackSelection(this._selection)}computeCursorState(model,helper){return helper.getTrackedSelection(this._selectionId)}}export function trimTrailingWhitespace(model,cursors){cursors.sort(((a,b)=>a.lineNumber===b.lineNumber?a.column-b.column:a.lineNumber-b.lineNumber));for(let i=cursors.length-2;i>=0;i--)cursors[i].lineNumber===cursors[i+1].lineNumber&&cursors.splice(i,1);const r=[];let rLen=0,cursorIndex=0;const cursorLen=cursors.length;for(let lineNumber=1,lineCount=model.getLineCount();lineNumber<=lineCount;lineNumber++){const lineContent=model.getLineContent(lineNumber),maxLineColumn=lineContent.length+1;let minEditColumn=0;if(cursorIndex<cursorLen&&cursors[cursorIndex].lineNumber===lineNumber&&(minEditColumn=cursors[cursorIndex].column,cursorIndex++,minEditColumn===maxLineColumn))continue;if(0===lineContent.length)continue;const lastNonWhitespaceIndex=strings.lastNonWhitespaceIndex(lineContent);let fromColumn=0;if(-1===lastNonWhitespaceIndex)fromColumn=1;else{if(lastNonWhitespaceIndex===lineContent.length-1)continue;fromColumn=lastNonWhitespaceIndex+2}fromColumn=Math.max(minEditColumn,fromColumn),r[rLen++]=EditOperation.delete(new Range(lineNumber,fromColumn,lineNumber,maxLineColumn))}return r}