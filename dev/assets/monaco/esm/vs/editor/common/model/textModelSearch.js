import*as strings from"../../../base/common/strings.js";import{getMapForWordSeparators}from"../core/wordCharacterClassifier.js";import{Position}from"../core/position.js";import{Range}from"../core/range.js";import{FindMatch,SearchData}from"../model.js";const LIMIT_FIND_COUNT=999;export class SearchParams{constructor(searchString,isRegex,matchCase,wordSeparators){this.searchString=searchString,this.isRegex=isRegex,this.matchCase=matchCase,this.wordSeparators=wordSeparators}parseSearchRequest(){if(""===this.searchString)return null;let multiline;multiline=this.isRegex?isMultilineRegexSource(this.searchString):this.searchString.indexOf("\n")>=0;let regex=null;try{regex=strings.createRegExp(this.searchString,this.isRegex,{matchCase:this.matchCase,wholeWord:!1,multiline,global:!0,unicode:!0})}catch(err){return null}if(!regex)return null;let canUseSimpleSearch=!this.isRegex&&!multiline;return canUseSimpleSearch&&this.searchString.toLowerCase()!==this.searchString.toUpperCase()&&(canUseSimpleSearch=this.matchCase),new SearchData(regex,this.wordSeparators?getMapForWordSeparators(this.wordSeparators):null,canUseSimpleSearch?this.searchString:null)}}export function isMultilineRegexSource(searchString){if(!searchString||0===searchString.length)return!1;for(let i=0,len=searchString.length;i<len;i++){const chCode=searchString.charCodeAt(i);if(10===chCode)return!0;if(92===chCode){if(i++,i>=len)break;const nextChCode=searchString.charCodeAt(i);if(110===nextChCode||114===nextChCode||87===nextChCode)return!0}}return!1}export function createFindMatch(range,rawMatches,captureMatches){if(!captureMatches)return new FindMatch(range,null);const matches=[];for(let i=0,len=rawMatches.length;i<len;i++)matches[i]=rawMatches[i];return new FindMatch(range,matches)}class LineFeedCounter{constructor(text){const lineFeedsOffsets=[];let lineFeedsOffsetsLen=0;for(let i=0,textLen=text.length;i<textLen;i++)10===text.charCodeAt(i)&&(lineFeedsOffsets[lineFeedsOffsetsLen++]=i);this._lineFeedsOffsets=lineFeedsOffsets}findLineFeedCountBeforeOffset(offset){const lineFeedsOffsets=this._lineFeedsOffsets;let min=0,max=lineFeedsOffsets.length-1;if(-1===max)return 0;if(offset<=lineFeedsOffsets[0])return 0;for(;min<max;){const mid=min+((max-min)/2>>0);lineFeedsOffsets[mid]>=offset?max=mid-1:lineFeedsOffsets[mid+1]>=offset?(min=mid,max=mid):min=mid+1}return min+1}}export class TextModelSearch{static findMatches(model,searchParams,searchRange,captureMatches,limitResultCount){const searchData=searchParams.parseSearchRequest();return searchData?searchData.regex.multiline?this._doFindMatchesMultiline(model,searchRange,new Searcher(searchData.wordSeparators,searchData.regex),captureMatches,limitResultCount):this._doFindMatchesLineByLine(model,searchRange,searchData,captureMatches,limitResultCount):[]}static _getMultilineMatchRange(model,deltaOffset,text,lfCounter,matchIndex,match0){let startOffset,endOffset,lineFeedCountBeforeMatch=0;if(lfCounter?(lineFeedCountBeforeMatch=lfCounter.findLineFeedCountBeforeOffset(matchIndex),startOffset=deltaOffset+matchIndex+lineFeedCountBeforeMatch):startOffset=deltaOffset+matchIndex,lfCounter){const lineFeedCountInMatch=lfCounter.findLineFeedCountBeforeOffset(matchIndex+match0.length)-lineFeedCountBeforeMatch;endOffset=startOffset+match0.length+lineFeedCountInMatch}else endOffset=startOffset+match0.length;const startPosition=model.getPositionAt(startOffset),endPosition=model.getPositionAt(endOffset);return new Range(startPosition.lineNumber,startPosition.column,endPosition.lineNumber,endPosition.column)}static _doFindMatchesMultiline(model,searchRange,searcher,captureMatches,limitResultCount){const deltaOffset=model.getOffsetAt(searchRange.getStartPosition()),text=model.getValueInRange(searchRange,1),lfCounter="\r\n"===model.getEOL()?new LineFeedCounter(text):null,result=[];let m,counter=0;for(searcher.reset(0);m=searcher.next(text);)if(result[counter++]=createFindMatch(this._getMultilineMatchRange(model,deltaOffset,text,lfCounter,m.index,m[0]),m,captureMatches),counter>=limitResultCount)return result;return result}static _doFindMatchesLineByLine(model,searchRange,searchData,captureMatches,limitResultCount){const result=[];let resultLen=0;if(searchRange.startLineNumber===searchRange.endLineNumber){const text=model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn-1,searchRange.endColumn-1);return resultLen=this._findMatchesInLine(searchData,text,searchRange.startLineNumber,searchRange.startColumn-1,resultLen,result,captureMatches,limitResultCount),result}const text=model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn-1);resultLen=this._findMatchesInLine(searchData,text,searchRange.startLineNumber,searchRange.startColumn-1,resultLen,result,captureMatches,limitResultCount);for(let lineNumber=searchRange.startLineNumber+1;lineNumber<searchRange.endLineNumber&&resultLen<limitResultCount;lineNumber++)resultLen=this._findMatchesInLine(searchData,model.getLineContent(lineNumber),lineNumber,0,resultLen,result,captureMatches,limitResultCount);if(resultLen<limitResultCount){const text=model.getLineContent(searchRange.endLineNumber).substring(0,searchRange.endColumn-1);resultLen=this._findMatchesInLine(searchData,text,searchRange.endLineNumber,0,resultLen,result,captureMatches,limitResultCount)}return result}static _findMatchesInLine(searchData,text,lineNumber,deltaOffset,resultLen,result,captureMatches,limitResultCount){const wordSeparators=searchData.wordSeparators;if(!captureMatches&&searchData.simpleSearch){const searchString=searchData.simpleSearch,searchStringLen=searchString.length,textLength=text.length;let lastMatchIndex=-searchStringLen;for(;-1!==(lastMatchIndex=text.indexOf(searchString,lastMatchIndex+searchStringLen));)if((!wordSeparators||isValidMatch(wordSeparators,text,textLength,lastMatchIndex,searchStringLen))&&(result[resultLen++]=new FindMatch(new Range(lineNumber,lastMatchIndex+1+deltaOffset,lineNumber,lastMatchIndex+1+searchStringLen+deltaOffset),null),resultLen>=limitResultCount))return resultLen;return resultLen}const searcher=new Searcher(searchData.wordSeparators,searchData.regex);let m;searcher.reset(0);do{if(m=searcher.next(text),m&&(result[resultLen++]=createFindMatch(new Range(lineNumber,m.index+1+deltaOffset,lineNumber,m.index+1+m[0].length+deltaOffset),m,captureMatches),resultLen>=limitResultCount))return resultLen}while(m);return resultLen}static findNextMatch(model,searchParams,searchStart,captureMatches){const searchData=searchParams.parseSearchRequest();if(!searchData)return null;const searcher=new Searcher(searchData.wordSeparators,searchData.regex);return searchData.regex.multiline?this._doFindNextMatchMultiline(model,searchStart,searcher,captureMatches):this._doFindNextMatchLineByLine(model,searchStart,searcher,captureMatches)}static _doFindNextMatchMultiline(model,searchStart,searcher,captureMatches){const searchTextStart=new Position(searchStart.lineNumber,1),deltaOffset=model.getOffsetAt(searchTextStart),lineCount=model.getLineCount(),text=model.getValueInRange(new Range(searchTextStart.lineNumber,searchTextStart.column,lineCount,model.getLineMaxColumn(lineCount)),1),lfCounter="\r\n"===model.getEOL()?new LineFeedCounter(text):null;searcher.reset(searchStart.column-1);const m=searcher.next(text);return m?createFindMatch(this._getMultilineMatchRange(model,deltaOffset,text,lfCounter,m.index,m[0]),m,captureMatches):1!==searchStart.lineNumber||1!==searchStart.column?this._doFindNextMatchMultiline(model,new Position(1,1),searcher,captureMatches):null}static _doFindNextMatchLineByLine(model,searchStart,searcher,captureMatches){const lineCount=model.getLineCount(),startLineNumber=searchStart.lineNumber,text=model.getLineContent(startLineNumber),r=this._findFirstMatchInLine(searcher,text,startLineNumber,searchStart.column,captureMatches);if(r)return r;for(let i=1;i<=lineCount;i++){const lineIndex=(startLineNumber+i-1)%lineCount,text=model.getLineContent(lineIndex+1),r=this._findFirstMatchInLine(searcher,text,lineIndex+1,1,captureMatches);if(r)return r}return null}static _findFirstMatchInLine(searcher,text,lineNumber,fromColumn,captureMatches){searcher.reset(fromColumn-1);const m=searcher.next(text);return m?createFindMatch(new Range(lineNumber,m.index+1,lineNumber,m.index+1+m[0].length),m,captureMatches):null}static findPreviousMatch(model,searchParams,searchStart,captureMatches){const searchData=searchParams.parseSearchRequest();if(!searchData)return null;const searcher=new Searcher(searchData.wordSeparators,searchData.regex);return searchData.regex.multiline?this._doFindPreviousMatchMultiline(model,searchStart,searcher,captureMatches):this._doFindPreviousMatchLineByLine(model,searchStart,searcher,captureMatches)}static _doFindPreviousMatchMultiline(model,searchStart,searcher,captureMatches){const matches=this._doFindMatchesMultiline(model,new Range(1,1,searchStart.lineNumber,searchStart.column),searcher,captureMatches,9990);if(matches.length>0)return matches[matches.length-1];const lineCount=model.getLineCount();return searchStart.lineNumber!==lineCount||searchStart.column!==model.getLineMaxColumn(lineCount)?this._doFindPreviousMatchMultiline(model,new Position(lineCount,model.getLineMaxColumn(lineCount)),searcher,captureMatches):null}static _doFindPreviousMatchLineByLine(model,searchStart,searcher,captureMatches){const lineCount=model.getLineCount(),startLineNumber=searchStart.lineNumber,text=model.getLineContent(startLineNumber).substring(0,searchStart.column-1),r=this._findLastMatchInLine(searcher,text,startLineNumber,captureMatches);if(r)return r;for(let i=1;i<=lineCount;i++){const lineIndex=(lineCount+startLineNumber-i-1)%lineCount,text=model.getLineContent(lineIndex+1),r=this._findLastMatchInLine(searcher,text,lineIndex+1,captureMatches);if(r)return r}return null}static _findLastMatchInLine(searcher,text,lineNumber,captureMatches){let m,bestResult=null;for(searcher.reset(0);m=searcher.next(text);)bestResult=createFindMatch(new Range(lineNumber,m.index+1,lineNumber,m.index+1+m[0].length),m,captureMatches);return bestResult}}function leftIsWordBounday(wordSeparators,text,textLength,matchStartIndex,matchLength){if(0===matchStartIndex)return!0;const charBefore=text.charCodeAt(matchStartIndex-1);if(0!==wordSeparators.get(charBefore))return!0;if(13===charBefore||10===charBefore)return!0;if(matchLength>0){const firstCharInMatch=text.charCodeAt(matchStartIndex);if(0!==wordSeparators.get(firstCharInMatch))return!0}return!1}function rightIsWordBounday(wordSeparators,text,textLength,matchStartIndex,matchLength){if(matchStartIndex+matchLength===textLength)return!0;const charAfter=text.charCodeAt(matchStartIndex+matchLength);if(0!==wordSeparators.get(charAfter))return!0;if(13===charAfter||10===charAfter)return!0;if(matchLength>0){const lastCharInMatch=text.charCodeAt(matchStartIndex+matchLength-1);if(0!==wordSeparators.get(lastCharInMatch))return!0}return!1}export function isValidMatch(wordSeparators,text,textLength,matchStartIndex,matchLength){return leftIsWordBounday(wordSeparators,text,textLength,matchStartIndex,matchLength)&&rightIsWordBounday(wordSeparators,text,textLength,matchStartIndex,matchLength)}export class Searcher{constructor(wordSeparators,searchRegex){this._wordSeparators=wordSeparators,this._searchRegex=searchRegex,this._prevMatchStartIndex=-1,this._prevMatchLength=0}reset(lastIndex){this._searchRegex.lastIndex=lastIndex,this._prevMatchStartIndex=-1,this._prevMatchLength=0}next(text){const textLength=text.length;let m;do{if(this._prevMatchStartIndex+this._prevMatchLength===textLength)return null;if(m=this._searchRegex.exec(text),!m)return null;const matchStartIndex=m.index,matchLength=m[0].length;if(matchStartIndex===this._prevMatchStartIndex&&matchLength===this._prevMatchLength){if(0===matchLength){strings.getNextCodePoint(text,textLength,this._searchRegex.lastIndex)>65535?this._searchRegex.lastIndex+=2:this._searchRegex.lastIndex+=1;continue}return null}if(this._prevMatchStartIndex=matchStartIndex,this._prevMatchLength=matchLength,!this._wordSeparators||isValidMatch(this._wordSeparators,text,textLength,matchStartIndex,matchLength))return m}while(m);return null}}